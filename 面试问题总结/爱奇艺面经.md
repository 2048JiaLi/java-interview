[TOC]

## 一、hashset底层实现

HashSet实际上是一个HashMap实例，都是一个**存放链表的数组**。它不保证存储元素的迭代顺序；此类允许使用null元素。HashSet中不允许有重复元素，这是因为HashSet是基于HashMap实现的，**HashSet中的元素都存放在HashMap的key上面**，而value中的值都是统一的一个固定对象`PRESENT`

```java
    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
```

HashSet中add方法调用的是底层HashMap中的**put()方法**，而如果是在HashMap中调用put，**首先会判断key是否存在，如果key存在则修改value值，如果key不存在这插入这个key-value**。而在set中，因为value值没有用，也就不存在修改value值的说法，因此**往HashSet中添加元素，首先判断元素（也就是key）是否存在，如果不存在这插入，如果存在着不插入，这样HashSet中就不存在重复值**。

 所以判断key是否存在就要重写元素的类的equals()和hashCode()方法，当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算次对象的哈希值，此哈希值决定了此对象在Set中存放的位置；若此位置没有被存储对象则直接存储，若已有对象则通过对象所在类的equals()比较两个对象是否相同，相同则不能被添加。

## 二、hashmap的put操作过程

i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；
ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；

iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。

## 三、线程池介绍

线程就是我们**程序执行的实体**。在服务器开发领域，我们经常会为每个请求分配一个线程去处理，但是**线程的创建销毁、调度都会带来额外的开销**，线程太多也会导致系统整体性能下降。在这种场景下，我们通常会提前创建若干个线程，通过线程池来进行管理。当请求到来时，只需从线程池选一个线程去执行处理任务即可。

线程池常常和**队列**一起使用来实现**任务调度**，主线程收到请求后将创建对应的任务，然后放到队列里，线程池中的工作线程等待队列里的任务。

## 四、数据库连接池介绍，底层实现

**数据库连接是一种关键的有限的昂贵的资源**。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。

**数据库连接池负责分配、管理和释放数据库连接**，它允许应用程序重复使用一个现有的数据库连接，而再不是重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。能明显提高对数据库操作的性能。

### 4.1 线程池有哪几种

```
Java通过Executors提供四种线程池，分别为：

newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
newWorkStealingPool jdk8增加了newWorkStealingPool(``int` `parall)，增加并行处理任务的线程池，不能保证处理的顺序。

线程池的组成部分
1、线程池管理器（ThreadPoolManager）:用于创建并管理线程池
2、工作线程（WorkThread）: 线程池中线程
3、任务接口（Task）:每个任务必须实现的接口，以供工作线程调度任务的执行。
4、任务队列:用于存放没有处理的任务。提供一种缓冲机制。
```

### 4.2 线程池的组成部分
1、线程池管理器（ThreadPoolManager）:用于创建并管理线程池
2、工作线程（WorkThread）: 线程池中线程
3、任务接口（Task）:每个任务必须实现的接口，以供工作线程调度任务的执行。
4、任务队列:用于存放没有处理的任务。提供一种缓冲机制。



> **一般来说，Java应用程序访问数据库的过程是**：
>
> ①装载数据库驱动程序；
>
> ②通过jdbc建立数据库连接；
>
> ③访问数据库，执行sql语句；
>
> ④断开数据库连接。
>
> 
>
> 底层实现可以说成是队列，比如可以用一个list实现一个简单的连接池
>
> ```java
> public class MyDataSource implements DataSource {
>   //链表 --- 实现栈结构
>   privateLinkedList<Connection> dataSources = new LinkedList<Connection>();
> 
>   //初始化连接数量
>   publicMyDataSource() {
>      //一次性创建10个连接
>      for(int i = 0; i < 10; i++) {
>         try {
>            //1、装载sqlserver驱动对象
>            DriverManager.registerDriver(new SQLServerDriver());
>            //2、通过JDBC建立数据库连接
>            Connection con =DriverManager.getConnection(
>             "jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer", "sa", "123");
>            //3、将连接加入连接池中
>            dataSources.add(con);
>         } catch (Exception e) {
>            e.printStackTrace();
>         }
>      }
>   }
> 
>   @Override
>   publicConnection getConnection() throws SQLException {
>      //取出连接池中一个连接
>      finalConnection conn = dataSources.removeFirst(); // 删除第一个连接返回
>      returnconn;
>   }
> 
>   //将连接放回连接池
>   publicvoid releaseConnection(Connection conn) {
>      dataSources.add(conn);
>   }
> }
> ```

### 4.2 线程的生命周期

```
新建：就是刚使用``new``方法，``new``出来的线程；
就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;
运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;
阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;
销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;
```

## 五、TCP与HTTP

- 建立起一个TCP连接需要经过“三次握手”：

   第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

   第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

   第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

-  HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础。最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

> 在TCP/IP概念模型中，http是应用层协议，TCP/UDP是传输层协议，IP是网络层
>
> HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP  

## 六、乐观锁和悲观锁的使用场景

### 6.1、定义

1、乐观锁：顾名思义，对每次的数据操作都保持乐观的态度，不担心数据会被修改，所以不会对数据进行上锁。由于数据没有上锁，这就存在数据会被多人读写的情况。所以每次修改数据的时候需要对数据进行判断是否被修改过。

2、悲观锁：与乐观锁相反，对每次的数据操作都保存悲观的态度，总是担心数据会被修改，所以在自己操作的时候会对数据上锁，防止在自己操作的时候被他人同时操作导致更新丢失。

### 6.2 **使用场景**

1、乐观锁：由于乐观锁的不上锁特性，所以在性能方面要比悲观锁好，比较适合用在DB的读大于写的业务场景。

2、悲观锁：对于每一次数据修改都要上锁，如果在DB读取需要比较大的情况下有线程在执行数据修改操作会导致读操作全部被挂载起来，等修改线程释放了锁才能读到数据，体验极差。所以比较适合用在DB写大于读的情况。

## 七、MySQL的四种事务隔离级别

### 7.1、事务的基本要素（ACID)

　　**1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。**

　　 **2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。**

　　 **3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。**

　　 **4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。**

### 7.2、事务的并发问题

1、 脏读：A，B两事务，A事务会读取到B事务未提交的数据，然后B因为某些原因回滚数据，所以**A就读取了B没有提交的数据**，也称脏数据。

2、 不可重复读：在A事务中**对同一数据两次查询不一致**，可能原因是在A事务提交之前B事务对该数据进行了操作

3、 幻读：类似于不可重复读，都是在一个事务周期内读的数据不一致，区别在于幻读是侧重于插入操作带来的影响，而不可重复读是编辑或者删除带来的影响



### 7.3、MySQL事务隔离级别

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

## 八、什么是幻读，如何解决

### 8.1、什么是幻读

   在一次事务里面，多次查询之后，查询的结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做 `幻行`

### 8.2、为什么要解决幻读

  在高并发数据库系统中，需要保证事务与事务之间的隔离性，还有事务本身的一致性。

### 8.3、如何解决幻读

- 多版本并发控制（MVCC）（快照读/一致性读）

   多数数据库都实现了多版本并发控制，并且都是**靠保存数据快照来实现的**。

  以 `InnoDB` 为例，每一行中都冗余了两个字断。一个是行的创建版本，一个是行的删除（过期）版本。

  具体的版本号（trx_id）存在 `information_schema.INNODB_TRX` 表中。

  版本号（trx_id）随着每次事务的开启自增。

  **事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。**

  普通的 select 就是快照读。

```
select * from T where number = 1;
```

  原理：**将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。**

- next-key 锁 （当前读）

next-key 锁包含两部分：记录锁（行锁）、间隙锁

**记录锁是加在索引上的锁，间隙锁是加在索引之间的。**（思考：如果列上没有索引会发生什么？）

```sql
select * from T where number = 1 for update;
select * from T where number = 1 lock in share mode;
insert into T values (...)
update T set number=''
delete from T where ...
```

原理：**将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。**