[TOC]

# 零、OSI七层模型

- 应用层：网络服务与最终用户的一个接口。
- 表示层：数据的表示、安全、压缩。
- 会话层：建立、管理、终止会话。
- 传输层：定义传输数据的协议端口号，以及流控和差错校验。
- 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。
- 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。
- 物理层：建立、维护、断开物理连接。

# 一、TCP与HTTP

>  在TCP/IP概念模型中，http是应用层协议，TCP/UDP是传输层协议，IP是网络层
>
> HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP  

## 1.1、TCP三次握手

建立起一个TCP连接需要经过“三次握手”：

- 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

### a、为什么要三次握手？

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

> 具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。

> 于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

### b、 **为什么要三次握手，两次不行吗？为什么？**

为了实现可靠数据传输， **TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的**。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。

**如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。**

## 1.2、四次挥手

当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。

**第一次分手**：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；

**第二次分手**：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
**第三次分手**：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；

**第四次分手**：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

## 1.3、HTTP

HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础。最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

**HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了。**

HTTP在每次请求结束后都会**主动释放连接**，因此HTTP连接是一种**“短连接”**，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。

> 通常的 做法是即时不需要获得任何数据，客户端也**保持每隔一段固定的时间向服务器发送一次“保持连接”的请求**，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

## 1.4、长连接和短连接

- 长连接：client与server建立连接，但是建立之后不断开，下次通信时直接进行报文发送和接收。

  > 这种方式下，通讯连接一直存在。此方式常用于P2P通信。
  >
  > HTTP首部的Connection: Keep-alive，表示的是默认为保持长连接。
  >
  > HTTP1.0协议不支持长连接，从HTTP1.1协议以后，连接默认都是长连接。

  ```undefined
  长连接是指的TCP连接，而不是HTTP连接。
  ```

- 短连接：client与server没进行一次报文收发时才进行通讯连接，且交易完成之后立即断开。

  > 此方式常用于一点对多点的通讯

### a、操作过程

短连接的操作步骤是：

建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接

长连接的操作步骤是：

建立连接——数据传输...**（保持连接）**...数据传输——关闭连接

> 即长连接不用每次都建立连接与断开连接（三次握手和四次挥手）

### b、HTTP协议长连接、短连接总结

长连接与短连接的不同主要在于client和server采取的关闭策略不同。短连接在建立连接以后只进行一次数据传输就关闭连接，而长连接在建立连接以后会进行多次数据数据传输直至关闭连接（长连接中关闭连接通过Connection：closed头部字段）。

二者关闭策略的不同，就产生了长连接的优点：

- 通过开启、关闭更少的TCP连接，节约CPU时间和内存
- 通过减少[TCP](http://www.nowamagic.net/academy/tag/TCP)开启引起的包的数目，降低网络阻塞。

> 长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。

二者所应用的具体场景不同。短连接多用于操作频繁、点对点的通讯，且连接数不能太多的情况。数据库的连接则采用长连接。

# 二、TCP与UDP的区别

TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景

|              | TCP                                              | UDP                            |
| ------------ | ------------------------------------------------ | ------------------------------ |
| **可靠性**   | 可靠                                             | 不可靠                         |
| **连接性**   | 面向连接                                         | 无连接                         |
| **报文**     | 面向字节流                                       | 面向报文                       |
| **效率**     | 传输效率低                                       | 传输效率高                     |
| **双工性**   | 全双工                                           | 一对一、一对多、多对一、多对多 |
| **流量控制** | 滑动窗口                                         | 无                             |
| **拥塞控制** | 慢开始、拥塞控制、快重传、快恢复                 | 无                             |
| **传输速度** | 慢                                               | 快                             |
| **应用场景** | 对效率要求低，对准确性要求高或者要求有连接的场景 | 对效率要求高，对准确性要求低   |

## 2.1、TCP和UDP都能用于广播吗？

- tcp不能进行广播和多播，因为tcp是面向连接的，需要有服务器和客户端的ip和端口才能进行通讯。

- 广播和组播都是udp才有的！

## 2.2、TCP如何保证可靠传输

- 建立连接：三次握手和四次挥手

- 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。

  > 什么时候重传：因为每个报文都有超时计数器，超时才重传。超时重传时间的选择也是一个策略。

- 流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。

  > 接收方处理不过来的时候，就把窗口缩小，并把窗口值告诉发送端。

- 拥塞控制：当网络拥塞时，减少数据的发送。

  > 四种拥塞控制算法，即**慢开始，拥塞避免、快重传、快恢复**。



# 三、HTTP与HTTPS的区别

HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

- HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全
- HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

## 3.1、主要区别

​    1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

​    2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。

​    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

​    4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 3.2、**客户端在使用HTTPS方式与Web服务器通信时的步骤**

​    （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL（Secure Socket Layer，安全套接字层）连接。

　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

　（3）客户端的浏览器与Web服务器开始**协商SSL/TLS连接的安全等级**，也就是信息加密的等级。

　（4）客户端的浏览器根据双方同意的安全等级，**建立会话密钥**，然后利用网站的公钥将会话密钥加密，并传送给网站。

　（5）Web服务器利用自己的私钥解密出会话密钥。

　（6）Web服务器利用会话密钥加密与客户端之间的通信。

## 3.3、HTTPS的缺点

- HTTPS协议多次握手，导致页面的加载时间延长近50%；
- HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；
- 申请SSL证书需要钱，功能越强大的证书费用越高。
- SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。

# 四、Get和Post

## 4.1、区别

（1） 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。

（2） GET方式提交的数据最多只能有1024字节，而POST则没有此限制。

（3） 安全性问题。正如在（1）中提到，使用 Get的时候，参数会显示在地址栏上，而 Post不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。

-  POST 是被设计用来向上放东西的，而GET是被设计用来从服务器取东西的，GET也能够向服务器传送较少的数据，而Get之所以也能传送数据,只是用来设计告诉服务器,你到底需要什么样的数据.POST的信息作为HTTP 请求的内容，而GET是在HTTP 头部传输的；
-  POST与GET在HTTP 中传送的方式不同，GET的参数是在HTTP 的头部传送的，而Post的数据则是在HTTP 请求的内容里传送;
-  POST传输数据时，不需要在URL中显示出来，而GET方法要在URL中显示；
-  GET方法由于受到URL长度的限制,只能传递大约1024字节；POST传输的数据量大，可以达到2M，而根据微软方面的说法，微软对用 Request.Form() 可接收的最大数据有限制，IIS 4 中为 80 KB 字节，IIS 5 中为 100 KB 字节；

# 五、Cookie 和 Session 

## 5.1、**什么是 Cookie**

- **HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息**）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
- **cookie 存储在客户端：** cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- **cookie 是不可跨域的：** 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，**一级域名和二级域名之间是允许共享使用的**（**靠的是 domain）**。

## 5.2、什么是 Session

- **session 是另一种记录服务器和客户端会话状态的机制**
- **session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中**

### a、**session 认证流程**

- 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
- 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
- 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
- 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

## 5.3、Cookie 和 Session 区别

- **安全性：** Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- **存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- **有效期不同：** Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- **存储大小不同：** 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

## 5.4、客户端禁止 cookie之后，session 还能用吗？

**一般默认情况下**，在会话中，服务器存储 session 的 sessionid 是通过 cookie 存到浏览器里。

如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，**session失效**。



但是可以**通过其他方法**在禁用 cookie 的情况下，**可以继续使用session**。

1. 通过url重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中携带 sessionid 参数。
2. 服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。
3. 通过 Http 协议其他 header 字段，服务器每次返回时设置该 header 字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该 header 字段。



# 六、OS调度算法

## 6.1、先来先服务

最先进入等待队列的，先获得CPU。

通过一个单链表可以实现，选取一个进程时，从链表头部取出该进程。添加作业时，在尾部进行添加

## 6.2、最短作业优先

CPU执行时间短的作业优先。

> 在所有的进程都可以运行的情况下，且运行时间片已知时，最短作业优先的算法才是最优的。
>
> 但是，这也是其缺点，通常情况下，这些信息是未知的。

## 6.3、轮转调度

每个进程都会被**分配一个时间段**，称为`时间片(quantum)`，在这个时间片内允许进程运行。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。

## 6.4、页面置换算法

- 先进先出
- 最近最久未使用：选择在最近一段时间内最久没有使用过的页，把它淘汰。
- 最少使用：选择到当前时间为止被访问次数最少的页转换

# 七、Linux常用命令

- free：查看内存
- pwd 显示工作路径