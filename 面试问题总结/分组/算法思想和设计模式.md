[TOC]

# 一、分治思想

奖大问题分解为若干个小问题，对每个小问题求解完成后，归并

- 能用分治法的基本特征：

1.问题缩小到一定规模容易解决

2.分解成的子问题是相同种类的子问题，即该问题具有最优子结构性质

> 某个问题的最优解包含着其子问题的最优解

3.分解而成的小问题在解决之后要可以合并

4.子问题是相互独立的

## 1.1、为什么要这样做

- 小问题容易解决，解决了众多的子问题，大问题也就更容易解决啦

## 1.2、如果拆分的父子问题有依赖关系怎么办？

大问题拆分的过程中，非常重要的即不同分支的子问题不能相互依赖，需要各自独立，因为如果存在依赖关系，父子问题就失去了「归并」的意义，那么在开发中，这就是「**聚合度**」和「**内聚度**」的问题。

## 1.3、什么是聚合度和内聚度？

- 所谓**聚合度**即软件系统中各个模块的相互依赖程度。比如在调用A方法的时候都需要**同步**调用方法B，显然这样的耦合度就高

- 所谓**内聚度**即模块之间具有共同点的相似程度，所以在拆分的时候要尤其注意这两点。

## 1.4、说说快排思想

**如果我们的每一次分区操作都能正好将数组分成大小接近相等的两个小区间，那么快排的时间复杂度和归并是差不多的，所以其时间复杂度为O(nlogn)**

这里特别注意所谓的每次分区操作有个前提条件，即选择的pivot很合适，能挣好的将大区间对等的一分为二，如果原来的数据是一件排好序的，我们选择最后一个元素为pivot，这样每次分区得到的两个区间是不均等，我们需要进行大约n次分区操作，每次分区平均扫描n/2个元素，此时的复杂度将退化为0(n ^ 2)

# 二、单例模式（双检锁的方式实现）

## 2.1、“不安全的”双检查锁机制实现

存在对象部分构造问题

```java
public class DoubleCheckLock {
    private static DoubleCheckLock instance;

    private DoubleCheckLock() {
    	// TODO
    }

    public static DoubleCheckLock getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckLock.class) {
                if (instance == null) {
                    instance = new DoubleCheckLock();
                }
            }
        }
        return instance;
    }
}
```

## 2.2、为什么线程不安全

当线程A执行到" instance = new DoubleCheckLock();"这一行，而线程B执行到外层"if (instance == null) "时，**可能出现instance还未完成构造，但是此时不为null**导致线程B获取到一个不完整的instance。

> 编译器会进行**指令重排序**，在不改变执行效果的前提下，对指令顺序进行调整，从而提高执行效率。
>
> 比如
>
> ```java
> int a = 1;
> String b = "b";
> ```
>
> 这两行毫无关联的操作指令，编译器可能会将其顺序调整为：
>
> ```java
> String b = "b";
> int a = 1;
> ```

- 对于`instance = new DoubleCheckLock();`，它分为三个步骤执行：

```
1.分配一块内存空间
2.在这块内存上初始化一个DoubleCheckLock的实例
3.将声明的引用instance指向这块内存
```

第2和第3个步骤都依赖于第1个步骤，但是2和3之间没有依赖关系，那么**如果编译器将2和3调换顺序**，变成了：

```
1.分配一块内存空间
2.将声明的引用instance指向这块内存
3.在这块内存上初始化一个DoubleCheckLock的实例
```

> 先将引用指向内存地址，再初始化实例

当线程A执行到第2步时，instance已经不为null了，因为它指向了这块内存，此时如果线程B走到了"if (instance == null)"，那么线程B其实拿到的还是一个null，因为这块内存还没有初始化

**指令重排序是导致出现线程不安全的直接原因，而根本原因则是对象实例化不是一个原子操作。**

> 对于"a = b" 这一操作指令，将a这个引用指向b这一对象的内存，只需要改变a的指针，因此该直接赋值操作是一个不可划分的原子操作。
>
> 
>
> 对于"i ++"这一操作指令，其实它分为三个步骤执行：
>
> - 读取i的值
> - 将i的值加1
> - 将新的值赋值给i

## 2.3、实现线程安全的双检锁（加上volatile修饰符）

```java
public class DoubleCheckLock {
    private static volatile DoubleCheckLock instance;

    private DoubleCheckLock() {
    	// TODO
    }

    public static DoubleCheckLock getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckLock.class) {
                if (instance == null) {
                    instance = new DoubleCheckLock();
                }
            }
        }
        return instance;
    }
}
```

## 2.4、volatile原则

### a、happens-before

> 前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。

### b、内存可见性

> 就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。

# 三、工厂模式

工厂模式并不是一个独立的设计模式，而是三种功能接近的设计模式的统称，分别为：

- **简单工厂模式**

- **工厂方法模式**

- **抽象工厂模式**

## 3.1、引入

创建代码时，一般会使用new关键字

这样的创建方式，在大多数情况下是没有问题的。但是，如果创建对象需要一系列复杂的初始化操作，如关联其他成员对象、查配置文件或数据库表等。构造函数的代码会很冗余，降低程序可读性。

**这时可以考虑引入特殊的类——工厂类，专门负责对象的创建工作。**

## 3.2、简单工厂类

根据形参决定具体的子类对象创建

## 3.3、工厂方法模式

**利用多态特性动态创建对象**，如面向接口编程



简单工厂模式的缺点在于如果增加新的工厂子类，创建方法中就要新增条件判断，违背了OOP的开发-封闭原则。

> 注：所谓面向对象的开放-封闭原则，就是在程序中对“扩展”开放，对“修改”封闭。如果每次业务改动都要增加新的if-else，就涉及对旧有代码的修改，不但容易出错，可读性也不好。

## 3.4、抽象工厂模式

把产品子类进行分组，同组中的不同产品由同一个工厂子类的不同方法负责创建，从而减少了工厂子类的数量。

# 四、排序算法

## 4.1、稳定/不稳定排序

- 如何区分？

稳定排序：排序前后两个相等的数相对位置不变，则算法稳定
非稳定排序：排序前后两个相等的数相对位置发生了变化，则算法不稳定

## 4.2、快速排序（不稳定）

- 时间复杂度
  - 平均时间复杂度是：O(nlogn)
  - 最差的情况：O( n^2 )

- 空间复杂度
  - 非递归：O(1)
  - **递归（递归树的消耗空间）**
    - 最优：O(nlongn)
    - 最差：O(n)，退化为冒泡排序

## 4.3、堆排序（不稳定）

- 时间复杂度：O(n log n)
- 空间复杂度：O(1)

## 4.4、归并（稳定）

- 算法描述
  - 把长度为n的输入序列分成两个长度为n/2的子序列；
  - 对这两个子序列分别采用归并排序；
  - 将两个排序好的子序列合并成一个最终的排序序列。

  

复杂度分析

- 时间复杂度：O(n log n)
- 空间复杂度：O(n)