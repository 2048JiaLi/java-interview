[TOC]

# 一、JVM

## 1.1、模型

- 程序计数器：当前线程所执行的字节码的行号指示器。
- 虚拟机栈：虚拟机栈描述的是 Java 方法执行的内存模型，栈帧结构，描述了局部变量表、操作数栈、动态链接、方法出口等信息。
- 堆：堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。
- 本地方法栈：线程开始调用本地方法时，会进入 个不再受 JVM 约束的世界。
- 方法区：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 1.2、Java类加载过程

Java 类加载需要经历以下7个过程：

1. 加载

   - 通过类的全限定名称获取该类的二进制流
   - 将二进制流中的静态存储结构转化为方法去运行时数据结构
   - 在内存中生成该类的`Class`对象，作为该类的数据访问入口

2. 验证：确保`Class`文件的字节流中信息不会危害到JVM

   - 文件格式验证
   - 元数据验证
   - 字节码验证
   - 符号引号验证

3. 准备：为类的静态变量分配内存并将其初始化为默认值。

   > 准备阶段不分配示例变量的内存，实例变量将会在对象实例化时随着对象一起分配在堆中

4. 解析：完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

5. 初始化：类加载的最后一步。前面的过程，除了加载阶段用户应用程序可以自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码。

6. 使用

7. 卸载

## 1.3、Java内存分配

- 寄存器：我们无法控制
- 静态域：`static`定义的静态成员
- 常量池：编译时被确定并保存在`.class`文件中的`final`常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法的名称和描述符）
- 非`RAM`存储：硬盘等永久存储空间
- 堆内存：new创建的对象和数组，由JVM自动GC管理，存取速度慢
- 栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可共享，但是大小与生存期必须确定，缺乏灵活性

## 1.4、解释内存中的栈（stack）、堆(heap)和静态存储区的用法。

通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过`new` 关键字和构造器创建的对象放在堆空间；程序中的字面量（`literal`）如直接书写的`100`、`“hello”`和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，**整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用**。

`String str = new String(“hello”);`

上面的语句中`str` 放在栈上，用`new`创建出来的字符串对象放在堆上，而“hel
lo”这个字面量放在静态存储区。

## 1.5、堆和栈的区别

### a、堆

1. Java的堆是一个运行时数据区，类的对象从堆中分配空间。这些对象通过`new`等指令建立，通过垃圾回收器来销毁。
2. 堆的**优势**是可以动态地分配内存空间，需要多少内存空间不必事先告诉编译器，因为它是在运行时动态分配的。但**缺点**是，由于需要在运行时动态分配内存，所以存取速度较慢。 

### b、栈

1. 栈中主要存放一些基本数据类型的变量（byte，short，int，long，float，double，boolean，char）和对象的引用。
2. 栈的**优势**是，存取速度比堆快，栈数据可以共享。但**缺点**是，存放在栈中的数据占用多少内存空间需要在编译时确定下来，缺乏灵活性。

# 二、GC

GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：`System.gc()` 或 `Runtime.getRuntime().gc()` ，**但 JVM 可以屏蔽掉显示的垃圾回收调用**。

垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。

> 在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS 的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。

## 2.1、哪些对象可以被回收？  -- 无用的对象

如何定义对象是无用的

- 引用计数

如果一个对象被别的对象进行了一次引用，那么该对象会有一个引用计数器，这个计数器+1；如果被释放一下，计数器会减一。当引用计数器的计数值为0时，这个对象就是无用的，此时就可以对其回收。

但是，这只是表面上的合理。当遇到循环引用问题时，如对象A引用了对象B，并且对象B也引用了对象A，那么这两个对象的计数器都不会是0，可是这两个对象都没有被其他对象引用，理论上应该是要被回收的。

- 可达性分析

可达性分析说的是从 GCRoots 的点作为起点，向下搜索，当找不到任何引用链的时候表示该对象为垃圾对象。那么**哪些对象可以被认为是 Roots 节点**呢？有 **Java 栈中的对象**，方法区的**静态属性**和**常量**以及**本地方法栈中的对象**。从这几种对象依次向下搜索，如果没有能达到 Roots 节点的对象就是垃圾对象，就说明可以被回收。

## 2.2、什么时候能回收？

在排除人为调用的时候，**垃圾回收都是发生在为新生对象进行内存分配的时候**，这个时候**如果内存空间不足就会触发 GC 进行垃圾回收**。

> Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：`System.gc()` 或 `Runtime.getRuntime().gc()` ，**但 JVM 可以屏蔽掉显示的垃圾回收调用**。
>
> 即，即使使用了gc()，JVM也没有立刻回收

## 2.3、怎么回收？

垃圾回收根据实现的方式不同有多种不同的算法实现。比如有标记清除算法，复制算法，标记整理算法，分代回收算法。

### a、标记清除算法

主要就是执行两个动作，一个是标记，另一个是对进行标记的对象内存进行清除回收。

> 算法的缺点就是会出现内存碎片化严重。从上图中可以看到，在进行内存回收后出现了严重的内存碎片化，这就导致在分配某些大对象的时候仍然会出现内存不够的情况，但是总体内存确是够的。

### b、复制算法

复制算法的实现方式比较简洁明了，就是霸道的把内存分成两部分，在平时使用的时候只用其中的固定一份，在当需要进行 GC 的时候，把存活的对象复制到另一部分中，然后将已经使用的内存全部清理掉。

> 虽然解决了标记清除的内存碎片化问题，但是很明显复制算法的内存的使用率大大下降，能使用的内存只有原来的一半了。

### c、标记整理算法

既然标记清除和复制算法各有优缺点，那自然的我们就想到是否可以把这两种算法结合起来，于是就出现了标记整理算法。标记阶段是标记清除算法一样，先标记出需要回收的部分，不过清除阶段不是直接清除，而是把存活的对象往内存的一端进行移动，然后清除剩下的部分。

> 标记整理的算法虽然可以解决上面两个算法的一些问题，但是还是需要先进行标记，然后进行移动，整个效率还是偏低的。

### d、分代回收算法

分代回收算法是目前使用较多的一种算法，这个不是一个新的算法，只是将内存进行的划分，不同区域的内存使用不同的算法。根据对象的存活时间将内存的划分为新生代和老年代，其中新生代包含 Eden 区和 S0，S1。在新生代中使用是复制算法，在进行对象内存分配的时候只会使用 Eden 和 S0 区，当发生 GC 的时候，会将存活的对象复制到 S1 区，然后循环往复进行复制。当某个对象在进行了 15 次GC 后依旧存活，那这个对象就会进入老年代。老年代因为每次回收的对象都会比较少，因此使用的是标记整理算法。

## 2.4、两种常见的回收机制

1. 定时回收
   每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢
2. 当垃圾占到某个百分比的时候，进行回收
   比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。

- 一般说来 JVM会采用两种机制结合的方式进行垃圾回收。