[TOC]

# 一、JVM

##  1.1、jvm 的主要组成部分及其作用

类加载器（ClassLoader）
运行时数据区（Runtime Data Area）
执行引擎（Execution Engine）
本地库接口（Native Interface）

- 作用

首先通过**类加载器会把 Java 代码转换成字节码**，**运行时数据区再把字节码加载到内存中**，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此**需要特定的命令解析器执行引擎，将字节码翻译成底层系统指令，再交由 CPU 去执行**，而这个过程中**需要调用其他语言的本地库接口来实现整个程序的功能**。

## 1.2、**JVM 运行时数据区**

- 程序计数器：当前线程所执行的字节码的行号指示器。
- 虚拟机栈：虚拟机栈描述的是 Java 方法执行的内存模型，栈帧结构，描述了局部变量表、操作数栈、动态链接、方法出口等信息。
- 堆：堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。
- 本地方法栈：线程开始调用本地方法时，会进入 个不再受 JVM 约束的世界。
- 方法区：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

> 1.7将常量池移到堆中
>
> 1.8移除永久代用MetaSpace代替

## 1.3、Java类加载过程

Java 类加载需要经历以下7个过程：

1. 加载

   - 通过类的全限定名称获取该类的二进制流
   - 将二进制流中的静态存储结构转化为方法去运行时数据结构
   - 在内存中生成该类的`Class`对象，作为该类的数据访问入口

2. 验证：确保`Class`文件的字节流中信息不会危害到JVM

   - 文件格式验证
   - 元数据验证
   - 字节码验证
   - 符号引号验证

3. 准备：为类的静态变量分配内存并将其初始化为默认值。

   > 准备阶段不分配示例变量的内存，实例变量将会在对象实例化时随着对象一起分配在堆中

4. 解析：完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

5. 初始化：类加载的最后一步。前面的过程，除了加载阶段用户应用程序可以自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码。

6. 使用

7. 卸载

## 1.4、Java内存分配

- 寄存器：我们无法控制
- 静态域：`static`定义的静态成员
- 常量池：编译时被确定并保存在`.class`文件中的`final`常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法的名称和描述符）
- 非`RAM`存储：硬盘等永久存储空间
- 堆内存：new创建的对象和数组，由JVM自动GC管理，存取速度慢
- 栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可共享，但是大小与生存期必须确定，缺乏灵活性

## 1.5、解释内存中的栈（stack）、堆(heap)和静态存储区的用法。

通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过`new` 关键字和构造器创建的对象放在堆空间；程序中的字面量（`literal`）如直接书写的`100`、`“hello”`和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，**整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用**。

`String str = new String(“hello”);`

上面的语句中`str` 放在栈上，用`new`创建出来的字符串对象放在堆上，而“hel
lo”这个字面量放在静态存储区。

## 1.6、堆和栈的区别

### a、堆

1. Java的堆是一个运行时数据区，类的对象从堆中分配空间。这些对象通过`new`等指令建立，通过垃圾回收器来销毁。
2. 堆的**优势**是可以动态地分配内存空间，需要多少内存空间不必事先告诉编译器，因为它是在运行时动态分配的。但**缺点**是，由于需要在运行时动态分配内存，所以存取速度较慢。 

### b、栈

1. 栈中主要存放一些基本数据类型的变量（byte，short，int，long，float，double，boolean，char）和对象的引用。
2. 栈的**优势**是，存取速度比堆快，栈数据可以共享。但**缺点**是，存放在栈中的数据占用多少内存空间需要在编译时确定下来，缺乏灵活性。

# 二、GC

GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：`System.gc()` 或 `Runtime.getRuntime().gc()` ，**但 JVM 可以屏蔽掉显示的垃圾回收调用**。

垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。

> 在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS 的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。

## 2.1、哪些对象可以被回收？  -- 无用的对象

如何定义对象是无用的

- **引用计数**

如果一个对象被别的对象进行了一次引用，那么该对象会有一个引用计数器，这个计数器+1；如果被释放一下，计数器会减一。当引用计数器的计数值为0时，这个对象就是无用的，此时就可以对其回收。

但是，这只是表面上的合理。当遇到循环引用问题时，如对象A引用了对象B，并且对象B也引用了对象A，那么这两个对象的计数器都不会是0，可是这两个对象都没有被其他对象引用，理论上应该是要被回收的。

- **可达性分析**

可达性分析说的是从 GCRoots 的点作为起点，向下搜索，当找不到任何引用链的时候表示该对象为垃圾对象。

那么**哪些对象可以被认为是 Roots 节点**呢？有 **Java 栈中的对象**，方法区的**静态属性**和**常量**以及**本地方法栈中的对象**。从这几种对象依次向下搜索，如果没有能达到 Roots 节点的对象就是垃圾对象，就说明可以被回收。

## 2.2、什么时候能回收？

在排除人为调用的时候，**垃圾回收都是发生在为新生对象进行内存分配的时候**，这个时候**如果内存空间不足就会触发 GC 进行垃圾回收**。

> Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：`System.gc()` 或 `Runtime.getRuntime().gc()` ，**但 JVM 可以屏蔽掉显示的垃圾回收调用**。
>
> 即，即使使用了gc()，JVM也没有立刻回收

## 2.3、怎么回收？

垃圾回收根据实现的方式不同有多种不同的算法实现。比如有标记清除算法，复制算法，标记整理算法，分代回收算法。

### a、标记清除算法

主要就是执行两个动作，一个是标记，另一个是对进行标记的对象内存进行清除回收。

> 算法的缺点就是会出现内存碎片化严重。从上图中可以看到，在进行内存回收后出现了严重的内存碎片化，这就导致在分配某些大对象的时候仍然会出现内存不够的情况，但是总体内存确是够的。

### b、复制算法

复制算法的实现方式比较简洁明了，就是霸道的把内存分成两部分，在平时使用的时候只用其中的固定一份，在当需要进行 GC 的时候，把存活的对象复制到另一部分中，然后将已经使用的内存全部清理掉。

> 虽然解决了标记清除的内存碎片化问题，但是很明显复制算法的内存的使用率大大下降，能使用的内存只有原来的一半了。

### c、标记整理算法

既然标记清除和复制算法各有优缺点，那自然的我们就想到是否可以把这两种算法结合起来，于是就出现了标记整理算法。标记阶段是标记清除算法一样，先标记出需要回收的部分，不过清除阶段不是直接清除，而是把存活的对象往内存的一端进行移动，然后清除剩下的部分。

> 标记整理的算法虽然可以解决上面两个算法的一些问题，但是还是需要先进行标记，然后进行移动，整个效率还是偏低的。

### d、分代回收算法

分代回收算法是目前使用较多的一种算法，这个不是一个新的算法，只是将内存进行的划分，不同区域的内存使用不同的算法。**根据对象的存活时间将内存的划分为新生代和老年代**。

因为新生代中的对象基本都是朝生夕死的(80%以上)，所以在**新生代使用的是复制算法**。

> 复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

当某个对象在进行了 15 次GC 后依旧存活，那这个对象就会进入老年代。**老年代因为每次回收的对象都会比较少，因此使用的是标记整理算法。**

## 2.4、垃圾回收器

**新生代收集器**：Serial、ParNew、Parallel Scavenge

**老年代收集器**：CMS、Serial Old、Parallel Old

**整堆收集器**： G1

## 2.5、两种常见的回收机制

1. 定时回收
   每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢
2. 当垃圾占到某个百分比的时候，进行回收
   比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。

- 一般说来 JVM会采用两种机制结合的方式进行垃圾回收。

# 三、Java类加载

## 3.1、类初始化顺序

1. 静态属性：static 开头定义的属性
2. 静态方法块： static {} 圈起来的方法块
3. 普通属性： 未带static定义的属性
4. 普通方法块： {} 圈起来的方法块
5. 构造函数： 类名相同的方法
6. 方法： 普通方法

如下：

```java
public class LifeCycle {
    // 静态属性
    private static String staticField = getStaticField();
    // 静态方法块
    static {
        System.out.println(staticField);
        System.out.println("静态方法块初始化");
        System.out.println("Static Patch Initial");
    }
    // 普通属性
    private String field = getField();
    // 普通方法块
    {
        System.out.println(field);
        System.out.println("普通方法块初始化");
        System.out.println("Field Patch Initial");
    }
    // 构造函数
    public LifeCycle() {
        System.out.println("构造函数初始化");
        System.out.println("Structure Initial ");
    }

    public static String getStaticField() {
        String statiFiled = "Static Field Initial";
        System.out.println("静态属性初始化");
        return statiFiled;
    }

    public static String getField() {
        String filed = "Field Initial";
        System.out.println("普通属性初始化");
        return filed;
    }   
    // 主函数
    public static void main(String[] argc) {
        new LifeCycle();
    }
}
```

执行结果：

```java
静态属性初始化
Static Field Initial
静态方法块初始化
Static Patch Initial
普通属性初始化
Field Initial
普通方法块初始化
Field Patch Initial
构造函数初始化
Structure Initial 
```

## 3.2、一个java文件中有几个类，编译后有几个class文件？

在一个源文件中**用class关键字定义了几个类**，编译的时候就会产生几个字节码文件

## 3.3、什么是双亲委派模型？

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。**类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。**

**双亲委派模型**：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。

# 四、局部变量为什么需要显式赋值，否则编译不了

1、**成员变量（全局变量）**是可以不经初始化的，在类加载过程的准备阶段即可给它**赋予默认值**，但**局部变量使用前需要显示赋予初始值**，javac不是推断不出不可以这样做，而是没有这么做，对于**成员变量而言，其赋值和取值访问的先后顺序具有不确定性**，对于成员变量可以在一个方法调用前赋值，也可以在方法调用后进行，这是运行时发生的，编译器确定不了，交给jvm去做比较合适。

2、而对于**局部变量而言，其赋值和取值访问顺序是确定的**。这样设计是一种约束，尽最大程度减少使用者犯错的可能。**假使局部变量可以使用默认值，可能总会无意间忘记赋值，进而导致不可预期的情况出现。**