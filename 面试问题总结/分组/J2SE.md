[TOC]

# 一、集合类

## 1.1、HashSet

### a、底层实现

HashSet实际上是一个HashMap实例，都是一个**存放链表的数组**。它不保证存储元素的迭代顺序；此类允许使用null元素。HashSet中不允许有重复元素，这是因为HashSet是基于HashMap实现的，**HashSet中的元素都存放在HashMap的key上面**，而value中的值都是统一的一个固定对象`PRESENT`

```java
    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
```

>  HashSet的实现方式是基于HashMap实现的，内部定义了一个`private transient HashMap<E,Object> map;`

HashSet中add方法调用的是底层HashMap中的**put()方法**，而如果是在HashMap中调用put，**首先会判断key是否存在，如果key存在则修改value值，如果key不存在这插入这个key-value**。而在set中，因为value值没有用，也就不存在修改value值的说法，因此**往HashSet中添加元素，首先判断元素（也就是key）是否存在，如果不存在这插入，如果存在着不插入，这样HashSet中就不存在重复值**。

- 判断key是否存在，插入元素

所以**判断key是否存在**就要重写元素的类的equals()和hashCode()方法，当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算对象的哈希值，此哈希值决定了此对象在Set中存放的位置；若此位置没有被存储对象则直接存储，若已有对象则通过对象所在类的equals()比较两个对象是否相同，相同则不能被添加。

### b、hashset去重原理

往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。

    情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。
    
    情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行 添加。
> 重复元素（equals为true不允许添加）]

### c、实现类

1. HashSet：按照哈希算法来存储集合中的对象，速度较快。

2. LinkedHashSet：不仅实现了哈希算法，还实现了链表的数据结构，提供了插入和删除的功能。当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。

3. TreeSet：实现了SortedSet接口（此接口主要用于排序操作，即实现此接口的子类都属于排序的子类）。

   > TreeSet中，add()，remove()，contains()方法的时间复杂度是O(logn)

4. EnumSet：专门为枚举类设计的**有序**集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。

## 1.2、HashMap

> 默认初始大小为16。（必须保证2的幂次，是因为操作 & 比 %更高效）
>
> 默认加载因子0.75
>
> 链表转红黑树阈值为8，红黑树转链表为6
>
> 哈希表最小树型化容量为64（**容量低于64时，哈希碰撞的机率比较大**，而这个时候出现长链表的可能性会稍微大一些，这种原因下产生的长链表，我们应该**优先选择扩容而避免不必要的树化**。）

### a、put操作过程

1. 如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；
2. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；
3. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。

### b、HashMap线程不安全的表现

> new HashMap() 等价于 new HashMap（16,0.75）,即默认长度是16，扩容是原来的两倍。
>
> Hashtable默认是11

**扩容**就是在put加入元素的个数超过`initialCapacity * loadFactor`的时候就会将内部Entry数组大小扩大至原来的2倍。然后将数组**元素按照新的数组大小重新计算索引**，放在新的数组中，**同时修改每个节点的链表关系**（主要是next和节点在链表中的位置）。

HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会**触发扩容操作**，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，**在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环**，导致在get时会出现死循环，所以HashMap是线程不安全的。

### c、resize具体过程

HashMap通过resize()方法进行扩容为原来的两倍

首先计算并确定新容量的大小newCap，并且创建新表`Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];`

遍历将原来table中的数据放到扩容后的新表中来（**1.7是头插法（只有链表），1.8是尾插法（链表+红黑树）**）

如果是树结构（长度大于8），则将树上的节点放到新表

如果是链表，新元素的位置会根据旧元素位置+旧数组长度进行判定是否需要移动

```
如果（e.hash & oldCap） == 0则该节点在新表的下标位置与旧表一致
如果（e.hash & oldCap） == 1则该节点在新表的下标位置为 j+oldCap
```

- resize发生在table初始化或者table中的节点数超过阈值时
- 每次扩容会新建table，容量为原来的2倍
- 扩容时，会将原table的节点rehash到新table中，但节点在新旧table中的位置存在联系：要么下标相同，要么相差一个oldCap（旧table的大小）

### d、实现类

1. HashMap：按照哈希算法来存取key，有很好的存取性能，和HashSet一样，要求覆盖equals()方法和hasCode()方法，同时也不能保证集合中每个key-value对的顺序。
2. LinkedHashMap：使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致。
3. TreeMap：一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。实现了SortedMap接口，**能对key进行排序**。TreeMap可以保证所有的key-value对处于有序状态。同样，TreeMap也有两种排序方式（自然排序、定制排序）

### e、HashMap是怎么解决哈希冲突的

Hashmap解决hash冲突，使用的是**链地址法**，即数组+链表的形式来解决。

put执行首先判断table[i]位置，如果为空就直接插入，不为空判断和当前值是否相等，相等就覆盖，如果不相等的话，**判断是否是红黑树节点，如果不是，就从table[i]位置开始遍历链表，相等覆盖，不相等插入。**

## 1.3、HashMap 和Hashtable 的区别? 

都实现了`Map` 接口，是将惟一键映射到特定的值上；主要区别在于：

1) `HashMap` 没有排序，允许一个`null` 键和多个`null` 值,而`Hashtable` 不允许；

2) `HashMap` 把`Hashtable` 的`contains` 方法去掉了，改成`containsvalue` 和`containsKey`,因为`contains` 方法容易让人引起误解；
3) `Hashtable` 继承自`Dictionary` 类，`HashMap` 是Java1.2 引进的`Map` 接口的实现；

> `Dictionary` 类已过时

4) `Hashtable` 的方法是`Synchronize` 的，而`HashMap` 不是，在多个线程访问`Hashtable` 时，不需要自己为它的方法实现同步，而`HashMap` 就必须为之提供外同步。`Hashtable` 和`HashMap` 采用的`hash/rehash` 算法大致一样，所以性能不会有很大的差异。

> HashMap初始容量16，Hashtable 初始容量11

## 1.4、ConcurrentHashMap

> 1.8之前采用分段锁，核心就是一句话：**只在必要的地方加锁，要保护的是数据不是程序**（缩小锁粒度）。
>
> 1.8之后使用CAS思想代替冗杂的分段锁实现。

### a、HashMap线程不安全

因为多线程环境下，**使用Hashmap进行put操作可能会引起死循环**，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。例如如下代码：

### b、Hashtable线程安全但效率低下

Hashtable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下Hashtable的效率非常低下。因为当一个线程访问Hashtable的同步方法时，其他线程访问Hashtable的同步方法时，**可能会进入阻塞状态**。

### c、ConcurrentHashMap分段锁（JDK1.7）

Hashtable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问Hashtable的线程都必须竞争同一把锁，

那假如**容器里有多把锁，每一把锁用于锁容器其中一部分数据**，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，

这就是ConcurrentHashMap所使用的**锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。**

> 有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要**按顺序**锁定所有段，操作完毕后，又**按顺序**释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁。

#### *.1、底层实现

首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

**ConcurrentHashMap 是由 Segment 数组结构和 HahEntry 数组结构组成**。

> Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。

```java
static class Segment<K,V> extends ReentrantLock implements Serializable {
}
```

一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，**每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。**



### d、CAS锁（1.8之后），乐观锁

> CAS：Compare and Swap，即比较再交换。

当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。**CAS是一种非阻塞式的同步方式**。

> **乐观锁一般会使用版本号机制或CAS算法实现。**

1. CAS是实现乐观锁的核心算法，包含3个参数：V（需要更新的变量），E（预期值）、N（最新值）
2. 只有V等于E时，V才会被设置为N
3. 如果V不等于E了，说明其它线程已经更新了V，此时该线程不做操作，返回V的真实值

> **Java中的指针：Unsafe类**
>
> Unsafe类就像它的名字一样，不安全，里面有一些向C语言的指针一样直接操作内存的方法。并且官方也不推荐直接使用Unsafe类。但是CAS的实现用到了这个类。
>
> sun.misc.Unsafe类方法以native修饰（java调用非java代码的接口）



#### *.1、ABA问题

ABA问题是CAS机制中出现的一个问题，若设计的CAS不满足原子操作，就会引发ABA问题。

> 不能把ABA问题归咎于CAS机制

一个线程把数据A变为了B，然后又重新变成了A。对于另外一个线程，读取时，没有办法区分A是否发生了变化（认为还是原来的A）

> **最常见的就是资金问题，也就是别人如果挪用了你的钱，在你发现之前又还了回来。但是别人却已经触犯了法律。**

#### *.2、自旋时间过长

使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。





### e、总结

- Hashtable的任何操作都会把整个表锁住，是阻塞的。好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调用都要排队，效率较低。

- ConcurrentHashMap 是设计为非阻塞的。**在更新时会局部锁住某部分数据**，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。



## 1.5、List介绍

- 集合中的对象按照索引的顺序排序，可以有重复的对象。**底层以数组实现**。

- List以线型方式存储，默认按元素的添加顺序设置元素的索引。

### a、List集合的主要实现类

1. ArrayList：可以理解为长度可变的数组。可以对集合中的元素快速随机访问，但是做插入或删除操作时效率较低。

   > ArrayList底层是动态增加的数组实现，每次添加元素时，先判断是否会越界（默认初始长度为10）。此时若越界，则新数组的长度为`int newCapacity = oldCapacity + (oldCapacity >> 1);`，即扩容1/2。
   >
   > 这里的动态扩容数组是以`Arrays.copyOf()`实现的，即新建一个长度为newCapacity 的新数组，然后将原数组元素复制

2. LinkedList：使用链表的数据接口。与ArrayList相反，插入或删除操作时速度快，但是随机访问速度慢。同时实现List接口和Deque接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素，也能将LinkedList当作双端队列使用，自然也可以被当作"栈来使用（可以实现“fifo先进先出，filo后入先出”）

### b、Arraylist 与 LinkedList 异同

- **1. 是否保证线程安全：** ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
- **2. 底层数据结构：** Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；
- **3. 插入和删除是否受元素位置的影响：** ① **ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行`add(E e)`方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② **LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。**
- **4. 是否支持快速随机访问：** LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
- **5. 内存空间占用：** ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。



### c、 ArrayList集合加入1万条数据，应该怎么提高效率

主要是由于扩容导致效率低下

在该场景下（已知容量大小），选择构造器方法ArrayList(int size) ，指定初始容量更优

# 二、深拷贝和浅拷贝

- 含义：假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。



深拷贝：除了对象本身被复制外，对象所包含的所有成员变量都会被复制，包括引用类型的成员对象

浅拷贝：只复制对象其中包含的值类型的成员变量，而引用类型的成员对象没有被复制

## 2.1、如何理解clone对象

> clone都是浅拷贝

### a、为什么需要clone

在实际编程过程中，我们常常要遇到这种情况：有一个对象 A，在某一时刻 A 中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B 任何改动都不会影响到A中的值，也就是说，**A与B是两个独立的对象，但B的初始值是由A对象确定的**。

在Java语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现clone（）方法是其中最简单，也是最高效的手段。

### b、new 一个对象的过程和 clone 一个对象的过程区别 

- **new操作符的本意是分配内存**。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。
- clone在第一步是和new相似的，都是分配内存，调用clone方法时，分配的内存和原对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。 

### c、如何实现对象克隆

两种方式：

1.实现Cloneable接口并重写Object类中的clone()方法；
2.实现 Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆

> 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object 类的 clone 方法克隆对象。

# 三、抽象类与接口

## 3.1、抽象类作用

- 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
- 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
- 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
- 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

> 抽象类的作用应该是实现多态，

**抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样**。由于抽象类不能实例化对象，所以**抽象类必须被继承，才能被使用**。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

## 3.2、抽象类和接口的异同

### a、区别

- 使用方式：
  抽象类只能够通过继承被使用
  接口必须通过实现被使用
- 实现方法：
  抽象类不仅可以提供抽象方法，也可以提供实现方法
  接口只能提供抽象方法，不能提供实现方法。 



1. 抽象类可以有构造方法，接口不能有

2. 普通类中拥有的成员变量、普通方法、静态方法，在抽象类都可以有

   > 接口中只能定义的变量是public static final（默认）

3. 接口只能提供抽象方法，不能提供实现方法

4. 抽象类中的抽象方法的访问修饰符可以是public、protecedt，但是接口中的方法只能是public abstract类型

### b、相同： 
1.不能够实例化 
2.可以将抽象类和接口类型作为引用类型 
3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要
被声明为抽象类 

> 注意：抽象方法不能被static、native（本地方法）、synchronized修饰。因为抽象方法需要子类重写。

## 3.3、抽象类能不能被实例化？

> 问题思考，抽象类既然有构造方法，那么能不能被实例化呢

- 结论：不能。

  抽象类不是具体的类，无法通过new的方式实例化，但是可以通过子类的构造方法间接实例化，也可以通过生成匿名类的方式来实现。

例如：

创建一个AbstractFruit抽象类

```java
public abstract class AbstractFruit {
    public AbstractFruit(){
        System.out.println("我是Fruit的抽象类，我被实例化了");
    }
    public abstract void say();
}
```

若直接使用`AbstractFruit abstractFruit = new AbstractFruit();`编译报错，所以抽象类不能直接被new出来



但是抽象类可以通过子类继承的方式实例化（并不是正真的实例化new）

```java
public class Orange extends AbstractFruit {
    public Orange() {
        System.out.println("我是Orange类，我被实例化了");
    }
    @Override
    public void say() {
        System.out.println("我是一个Orange");
    }
    
    public static void main(String[] args) {
        Orange orange = new Orange();
    }
}
```

测试结果如下：

```java
我是Fruit的抽象类，我被实例化了
我是Orange类，我被实例化了
```

## 3.4、接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?

- 接口可以继承接口。

  > 比如List 就继承了接口Collection

- 接口支持多继承，一个接口可以有多个父接口，子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。
- 一个接口继承多个父接口时，多个父接口排在extends关键字之后。

```java
interface interfaceA
{
   int PROP_A = 5;
   void testA();
}
interface interfaceB
{
   int PROP_B = 6;
   void testB();
}
interface interfaceC extends interfaceA, interfaceB
{
   int PROP_C = 7;
   void testC();
}
public class InterfaceExtendsTest
{
   public static void main(String[] args)
   {
      System.out.println(interfaceC.PROP_A);
      System.out.println(interfaceC.PROP_B);
      System.out.println(interfaceC.PROP_C);
   }
}
```

> interfaceC接口继承了 interfaceA和 interfaceB，所以 interfaceC中获得了它们的常量，因此在main()方法中看到通过 interfaceC来访问PROP_A、PROP_B、PROP_C常量。



- 抽象类可以实现(implements)接口，抽象类可继承具体类，但前提是具体类必须有明确的构造函数。

  > 所有抽象类，都继承了Object

# 四、i++与++i

## 4.1、i++与++i的区别

栈帧结构有：局部变量表、操作数栈等等

- 对于i++，其先将i的值入栈（操作数栈），然后栈中数值加+1，此时局部变量表中i值未改变

- 对于++i，首先将局部变量表中i值+1，然后再入栈，此时局部变量表和操作数栈中的i都为+1之后的结果



## 4.2、i++不是原子操作

`i++`做了三次指令操作，两次内存访问，第一次，从内存中读取i变量的值到CPU的寄存器，第二次在寄存器中的i自增1，第三次将寄存器中的值写入内存。

`i++`在作计算的时候要引入一个临时的变量，底层是这样实现的：

```java
tmp = i;
i = i+1;
i = tmp;
```

若换做是`j = i++;`则

```
tmp = i;
i = i++;
j = tmp;
```

# 五、&（按位与）与&&（逻辑与）的区别

对于：&  -- >  不管怎样，都会执行"&"符号左右两边的程序

对于：&& -- >  只有当符号"&&"左边程序为真(true)后，才会执行符号"&&"右边的程序

**运算规则：**

对于：&  -- >  只要左右两边有一个为false，则为false；只有全部都为true的时候，结果为true

对于：&& -- > 只要符号左边为false，则结果为false；当左边为true，同时右边也为true，则结果为true

# 六、==与equals相关

## 6.1、==与equals区别

- ==比较的是对象的地址是否相等（基本数据类型则直接比较值），==比较为true，则两个对象必然是相同的，但是，两个值相同的对象，==比较并不一定为true

==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是 否相同，**要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。** 

- equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较 的两个对象是独立的。

> equals方法需要经过重写，才能实现对象值得比较，在Object类中也只是用了==操作符
>
> 如String中的equals方法，需要在相同长度的两个字符串中依此对比相同位置下的char[i]是否相等（基本类型，==）若存在不相等，返回false

## 6.2、为什么重写equals时必须重写hashCode方法？

不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hashCode）应当相同。 



Java 对于eqauls 方法和 hashCode 方法是这样规定的：

- (1)如果两个对象相同（equals 方法返回 true），那么它们的hashCode 值一定要相同；
- (2)如果两个对象的 hashCode 相同，它们并不一定相同。

> 当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 



# 七、java八大基本数据类型，与其对应的引用类型的区别

Java 提供两种不同的类型：引用类型和基本类型（或内置类型）；
`int` 是java 的基本数据类型，`Integer` 是java 为`int` 提供的封装类。

Java 为每个原始类型提供了封装类：

- 原始类型: `boolean,char,byte,short,int,long,float,double`
- 封装类型：`Boolean，Character，Byte，Short，Integer，Long，Float，Double`

引用类型和原始类型的行为完全不同，并且它们具有不同的语义。**引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题**，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为null，而原始类型实例变量的缺省值与它们的类型有关。

## 7.1、拆箱与装箱

> jdk5之后提供基本类型的自动装箱与拆箱

**装箱就是将基本数据类型转化为包装类型，那么拆箱就是将包装类型转化为基本数据类型**。

```java
public class TestBox {
    public static void main(String[] args) {
        //自动装箱，底层其实执行了Integer a=Integer.valueOf(1);
        Integer a = 1;
        //自动拆箱，底层其实执行了int b=a.intValue();
        int b = a;
    }
}
```

- Integer的`valueOf（int i）`方法可以将一个基本数据类型转化为对应的包装类型，即装箱方法。
- 而Integer的`intValue（）`方法则可以将一个包装类型转化为对应的基本数据类型，即拆箱方法。

## 7.2、装箱与自动装箱

装箱：利用Integer的构造方法Integer（int value），即Integer c=new Integer(1);

自动装箱：或者叫隐式装箱，直接给Integer赋值，即Integer d=1,在编译的时候，会调用Integer.valueOf（）方法完成装箱。

相比而言，自动装箱可能比装箱具有更高的效率，体现在自动装箱的缓存上，下面从几道题目来讲自动装箱的缓存。

# 八、String、StringBuffer、StringBuild区别

- 运行速度快慢为：`StringBuilder > StringBuffer > String`
  - （`String`为字符串常量，而`StringBuilder`和`StringBuffer`均为字符串变量，即`String`对象一旦创建之后该对象是**不可更改**的）
- `StringBuilder`是线程不安全的，而`String`、`StringBuffer`是线程安全的

## 8.1、String

### a、String创建的对象为什么不能修改

JDK1.8，String源码

- 变量

```java
/** The value is used for character storage. */
private final char value[];

/** Cache the hash code for the string */
private int hash; // Default to 0
```

> String内部是字符数组的实现，且定义为`private final`。并没有提供额外的set方法来修改，所以String类的外部无法修改String。一旦初始化之后，就不能再修改。

虽然String类中提供的一些方法替换某些值，如replace， replaceAll， toLowerCase等。但是，在调用这些方法时，内部new了一个新的String对象（见源码）并返回。所以，这些方法并不是真的改变了原String的值。

### b、是否可以继承String 

String被定义为`public final class String`，不可被继承

# 九、final关键字

## 9.1、修饰类、方法和变量的区别

在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）

- 修饰类：当用final修饰一个类时，表明这个类不能被继承。

  > final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

- 修饰方法：该方法在子类中，不能被覆盖

  > 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。

  注：类的private方法会隐式地被指定为final方法。

- 修饰变量：对于一个final变量，如果是**基本数据类型**的变量，则其数值一旦在初始化之后便**不能更改**；如果是**引用类型**的变量，则在对其初始化之后便**不能再让其指向另一个对象**。

## 9.2、修饰一个变量时，是引用不能变，还 是引用的对象不能变？ 

使用final 关键字修饰一个变量时，是指**引用变量不能变，引用变量所指向的对象中的内容还是可以改变的**。例如，对于如下语句： 

```java
final StringBuffer a=new StringBuffer("immutable");
```

> **此时`System.out.println(a);`输出`immutable`**

执行如下语句将报告编译期错误： 

```java
a=new StringBuffer(""); 
```

但是，执行如下语句则可以通过编译： 

```java
a.append(" broken!"); 
```

> **此时`System.out.println(a);`输出`immutable broken!`**

> 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： `public void method(final StringBuffer param){ }` 
>
> 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： `param.append("a"); `

# 十、反射

## 10.1、什么是反射机制？

> 运行时操作一个类的神器，可以获取构造器，方法，成员变量，参数化类型

  在程序运行状态中，对于任意一个类或对象，都能够获取到这个类的所有属性和方法（包括私有属性和方法），这种**动态获取信息以及动态调用对象方法的功能就称为反射机制**。简单来讲，通过反射，类对我们是完全透明的，想要获取任何东西都可以。

## 10.2、反射的优点

1. 可以在程序**运行过程中，操作这些对象**；
2. 可以解耦，提高程序的可扩展性。

## 10.3、private修饰的方法可以通过反射访问，那么private的意义是什么？

主要以下两点

- private修饰符并不是为了绝对安全性设计的，更多的是对用户常规使用java的一种约束
- 从外部对对象进行常规调用时，能够看到清晰的类结构（封装）

# 十二、序列化、反序列化

当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以**二进制序列**的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。

只能将支持 java.io.Serializable 接口的对象写入流中。每个 serializable 对象的类都被编码，编码内容包括类名和类签名、对象的字段值和数组值，以及从初始对象中引用的其他所有**对象的闭包**。

**1.概念**

　　序列化：把Java对象转换为字节序列的过程。
　　反序列化：把字节序列恢复为Java对象的过程。

**2.用途**

　　对象的序列化主要有两种用途：
　　1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
　　2） 在网络上传送对象的字节序列。

### 12.1、transient关键字

- 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。

- transient关键字只能修饰变量，而不能修饰方法和类。

  > 注意，本地变量是不能被transient关键字修饰的。

- 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。

# 十三、作用域public,private,protected,以及不写时default的区别

| 作用域    | 当前类 | 同包 | 子孙类 | 其他 |
| --------- | ------ | ---- | ------ | ---- |
| public    | √      | √    | √      | √    |
| protected | √      | √    | √      | ×    |
| default   | √      | √    | ×      | ×    |
| private   | √      | ×    | ×      | ×    |

# 十四、重载与重写有什么区别？

- override（重写）

1. 方法名、参数、返回值相同。
2. 子类方法**不能缩小父类方法**的访问权限。
3. 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。
4. 存在于父类和子类之间。 
5. 方法被定义为`final`不能被重写。

- overload（重载）

1. 参数类型、个数、顺序至少有一个不相同。 
2. 不能重载只有返回值不同的方法名。
3. 存在于父类和子类、同类中。

# 十五、This和super的区别和应用

- A:this和super都代表什么
  - this:代表当前对象的引用,谁来调用我,我就代表谁
  - super:代表当前对象父类的引用
- B:this和super的使用区别
  - a:调用成员变量
    - this.成员变量 调用本类的成员变量,也可以调用父类的成员变量
    - super.成员变量 调用父类的成员变量
  - b:调用构造方法
    - this(...) 调用本类的构造方法
    - super(...) 调用父类的构造方法
  - c:调用成员方法
    - this.成员方法 调用本类的成员方法,也可以调用父类的方法
    - super.成员方法 调用父类的成员方法

# 十六、Java面向对象编程的三大特性：封装、继承、多态

#### 封装

封装把一个个对象的属性私有化，同时可提供一些可以被外界访问的属性和方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义。

#### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或者新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承我们能够非常方便的复用以前的代码。

>  注意以下三点：
>
> 1.子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有。**
>
> 2.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
>
> 3.子类可以用自己的方式实现父类的方法。

#### 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法。

**必须在由程序运行期间才能决定。**

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口(实现接口并堵盖接口中同一方法)。

# 十七、异常处理

**try 块：**用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。

**catch 块：**用于处理try捕获到的异常。

**finally 块：**无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

- **以下4种特殊情况下，finally块不会被执行**
  - 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
  - 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
  - 程序所在的线程死亡。
  - 关闭CPU。

## 17.1、异常分三类

1. 错误：

   >  Error，指的是系统级别的异常，通常是内存用光了
   > 在默认设置下，一般java程序启动的时候，最大可以使用16m的内存

2. 运行时异常

3. 可查异常

## 17.2、运行时异常与一般异常有何异同？

### a、运行时异常

运行时异常(RuntimeException) 又叫做非可查异常，在编译过程中，**不要求必须进行显示捕捉**

> 常见的RuntimeException
>
> 1）java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。 
>
> 2）java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序
> 试图通过字符串来加载某个类时可能引发异常。
>
> 3）java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生
>
> 4）java.lang.NoClassDefFoundException 未找到类定义错误。
>
> 5）SQLException SQL异常，常见于操作数据库时的SQL语句错误。

Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常**太过于普遍**，如果都需要进行捕捉，代码的可读性就会变得很糟糕。

### b、一般异常

一般异常又叫做可查异常
可查异常： CheckedException
可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException
如果不处理，编译器，就不让你通过

## 17.3、Error和Exception有什么区别?

- Error和Exception都实现了Throwable接口

- Error指的是JVM层面的错误，比如内存不足OutOfMemoryError
- Exception 指的是代码逻辑的异常，比如下标越界OutOfIndexException

# 十八、IO流

## 18.1、流

- 流是个抽象的概念,是对输入输出设备的抽象，输入流可以看作一个输入通道，输出流可以看作一个输出通道。
- 输入流是相对程序而言的，外部传入数据给程序需要借助输入流。
- 输出流是相对程序而言的，程序把数据传输到外部需要借助输出流。

### a、什么是字节流？

字节流--传输过程中，传输数据的最基本单位是字节的流。

> 字节数据是二进制形式的，要转成我们能识别的正常字符，需要选择正确的编码方式。

### b、什么是字符流？

字符流--传输过程中，传输数据的最基本单位是字符的流。

> 字符编码方式不同，有时候一个字符使用的字节数也不一样，比如ASCLL方式编码的字符，占一个字节；而UTF-8方式编码的字符，一个英文字符需要一个字节，一个中文需要三个字节。

## 18.2、Java IO流分为几种

**按照流的流向分**，可以分为输入流和输出流；

**按照操作单元划分**，可以划分为字节流和字符流；

**按照流的角色划分**为节点流和处理流。

InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。

OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

## 18.3、BIO,NIO,AIO 有什么区别?

### a、**BIO (Blocking I/O)** 

**同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。**

每个TCP连接进来服务端都需要创建一个线程来建立连接并进行消息的处理。如果中间发生了阻塞(比如建立连接、读数据、写数据时发生阻碍)，线程也会发生阻塞，并发情况下，N个连接需要N个线程来处理。

> 在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

### b、NIO (New I/O)

> JDK1.4提出

NIO 也就是非阻塞IO，是基于事件驱动的思想(Reactor线程模型)。对比与BIO来说，NIO使用一个线程来管理所有的Socket 通道，也就是基于Selector机制，当查询到事件时(连接、接受连接、读、写)，就会转发给不同的处理线程(handler)。

**它支持面向缓冲的，基于通道的I/O操作方法**。 对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发

### c、AIO (Asynchronous I/O)

AIO 也就是 NIO 2。在 Java 7 中引入,它是**异步非阻塞的IO模型**。

异步 IO 是**基于事件和回调机制实现的**，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。

# 十九、创建对象的方式

- 使用new创建对象

  > 使用new创建对象会增加耦合度。无论使用什么框架，都要减少new的使用以降低耦合度。

- 反射机制

  - Class类的newInstace方法

    

    ```java
    Class heroClass = Class.forName("yunche.test.Hello");
    Hello h =(Hello) heroClass.newInstance();
    h.sayWorld();
    ```

  - Constructor类的newInstance方法

    ```java
    //获取类对象
    Class heroClass = Class.forName("yunche.test.Hello");
    
    //获取构造器
    Constructor constructor = heroClass.getConstructor();
    Hello h =(Hello) constructor.newInstance();
    h.sayWorld();
    ```

- 使用clone：需要实现`Cloneable`接口

  > clone时，需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。

- 序列化机制

  > 实现Serializable接口，将一个对象序列化到磁盘上，而采用反序列化可以将磁盘上的对象信息转化到内存中。

# 二十一、红黑树、B+树

