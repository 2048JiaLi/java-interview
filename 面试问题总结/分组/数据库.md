

[TOC]

# 一、数据库连接池

## 1.1、数据库连接池介绍

**数据库连接是一种关键的有限的昂贵的资源**。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。

**数据库连接池负责分配、管理和释放数据库连接**，它允许应用程序重复使用一个现有的数据库连接，而再不是重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。能明显提高对数据库操作的性能。

- **底层实现可以说成是队列**，比如可以用一个list实现一个简单的连接池

```java
public class MyDataSource implements DataSource {
//链表 --- 实现栈结构
privateLinkedList<Connection> dataSources = new LinkedList<Connection>();

//初始化连接数量
publicMyDataSource() {
  //一次性创建10个连接
  for(int i = 0; i < 10; i++) {
     try {
        //1、装载sqlserver驱动对象
        DriverManager.registerDriver(new SQLServerDriver());
        //2、通过JDBC建立数据库连接
        Connection con =DriverManager.getConnection(
         "jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer", "sa", "123");
        //3、将连接加入连接池中
        dataSources.add(con);
     } catch (Exception e) {
        e.printStackTrace();
     }
  }
}

@Override
publicConnection getConnection() throws SQLException {
  //取出连接池中一个连接
  finalConnection conn = dataSources.removeFirst(); // 删除第一个连接返回
  returnconn;
}

//将连接放回连接池
publicvoid releaseConnection(Connection conn) {
  dataSources.add(conn);
}
}
```

## 1.2、JDBC连接数据库步骤

- **一般来说，Java应用程序访问数据库的过程是**：

  ①装载数据库驱动程序；

  ②通过jdbc建立数据库连接；

  ③访问数据库，执行sql语句；

  ④断开数据库连接。

# 二、事务

## 2.1、什么是事务

**数据库事务**通常**指对数据库进行读或写的一个操作序列**。

- 它的存在包含有以下两个目的：
  - 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
  - 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

**系统中的事务**: 处理一系列业务处理的执行逻辑单元,该单元里的一系列类操作**要不全部成功要不全部失败。**

## 2.2、为什么使用事务

可以保证数据的一致性和完整性(避免异常和错误等导致的数据信息异常) 

## 2.3、事务的基本要素（ACID)

### a、原子性（Atomicity )

**事务的原子性是指事务必须是一个原子的操作序列单元。**

事务中包含的各项操作在一次执行过程中，**只允许出现以下两种状态之一**。
•全部成功执行。
•全部不执行。
任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只当所有的操作全部成功，整个事务才算是成功完成。

### b、一致性（Consistency )

**事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。**

### c、隔离性（Isolation) 

**隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰**。

**比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。**



在**标准SQL规范中，定义了 4个事务隔离级别**，不同的隔离级别对事务的处理不同， 如**未授权读取、授权读取、可重复读取和串行化**

- ①未授权读取
  未授权读取也被称为读未提交（Read Uncommitted),该隔离级别允许脏读取，其隔离级別最低。换句话说，如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有进行事务提交，而与此同时，允许另一个事务也能够访问该数据。举个例子来说，事务A和事务B同时进行，事务A在整个执行阶段，会将某数据项的值从1开始，做一系列加法操作（比如说加1操作）直到变成10之后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2、2变成3等），而对这一系列的中间值的读取就是未授权读取。

- ②授权读取
  授权读取也被称为读已提交（Read Committed),它和未授权读取非常相近，唯一的区别就是授权读取只允许获取已经被提交的数据。同样以上面的例子来说，事务 A和事务同时进行，事务A进行与上述同样的操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。

另外，如果说有一个事务C,和事务A进行非常类似的操作，只是事务C是将数据项从10加到 20,此时事务B也同样可以读取到20,即授权读取允许不可重复读取。

- ③可重复读取
  可重复读取（Repeatable Read),简单地说，就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的。因此该事务级別禁止了不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到 1，但是在下一次事务操作中，即使事务 B (注意，事务名字虽然相同，但是指的是另一次事务操作）采用同样的查询方式，就吋能会读取到10或20。

- ④串行化

串行化（ Serializable)是最严格的事务隔离级別。它要求所有事务都被串行执行，即事务只能一个接一个地进行处理，不能并发执行。

### d、持久性（Durability)

事务的**持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的**。

## 2.4、事务的并发问题（违背隔离性产生的问题）

### a、脏读

脏读：A，B两事务，A事务会读取到B事务未提交的数据，然后B因为某些原因回滚数据，所以**A就读取了B没有提交的数据**，也称脏数据。

### b、不可重复读

不可重复读：在A事务中**对同一数据两次查询不一致**，可能原因是在A事务提交之前B事务对该数据进行了操作

### c、幻读

#### *.1、什么是幻读

在一次事务里面，多次查询之后，查询的结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做 `幻行`

#### *.2、为什么要解决幻读

在高并发数据库系统中，需要保证事务与事务之间的隔离性，还有事务本身的一致性。

#### *.3、如何解决幻读

- 多版本并发控制（MVCC）（快照读/一致性读）

  多数数据库都实现了多版本并发控制，并且都是**靠保存数据快照来实现的**。

  以 `InnoDB` 为例，每一行中都冗余了两个字断。一个是行的创建版本，一个是行的删除（过期）版本。

  具体的版本号（trx_id）存在 `information_schema.INNODB_TRX` 表中。

  版本号（trx_id）随着每次事务的开启自增。

  **事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。**

  普通的 select 就是快照读。

```
select * from T where number = 1;
```

  原理：**将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。**

- next-key 锁 （当前读）

next-key 锁包含两部分：记录锁（行锁）、间隙锁

**记录锁是加在索引上的锁，间隙锁是加在索引之间的。**（思考：如果列上没有索引会发生什么？）

```sql
select * from T where number = 1 for update;
select * from T where number = 1 lock in share mode;
insert into T values (...)
update T set number=''
delete from T where ...
```

原理：**将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。**

## 2.5、MySQL事务隔离级别

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

- 读未提交（read-uncommitted）：`最低级别，任何情况都无法保证`

- 不可重复读（read-committed）：`避免脏读`

  > 在开始读取数据（事务开启）时，不再允许修改操作。

- 串行化（serializable）：`可避免脏读、不可重复读、幻读`

  > Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。**但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。**

## 2.6、**三范式**

> 第一范式: 每个列都不可以再拆分.
>
> 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分.
>
> 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.

# 三、Java事务

实际上，一个Java应用系统，如果要操作数据库，则通过JDBC来实现的。增加、修改、删除都是通过相应方法间接来实现的，事务的控制也相应转移到Java程序代码中。因此，数据库操作的事务习惯上就称为Java事务。

## 3.1、为什么需要Java事务?

事务是为解决数据安全操作提出的，事务控制实际上就是控制数据的安全访问。

```
一个简单例子：比如银行转帐业务，账户A要将自己账户上的1000元转到B账 户下面，A账户余额首先要减去1000元，然后B账户要增加1000元。假如在中间网络出现了问题，A账户减去1000元已经结束，B因为网络中断而操作 失败，那么整个业务失败，必须做出控制，要求A账户转帐业务撤销。这才能保证业务的正确性，完成这个操作就需要事务，将A账户资金减少和B账户资金增加方 到一个事务里面，要么全部执行成功，要么操作全部撤销，这样就保持了数据的安全性。
```

## 3.2、Java事务的类型

Java事务的类型有三种：**JDBC事务、JTA（Java Transaction API）事务、容器事务。**

### a、**JDBC事务**

JDBC 事务是用 Connection 对象控制的。JDBC Connection 接口（ java.sql.Connection ）提供了两种事务模式：自动提交和手工提交。

> 在连接数据库时，会通过Connection 对象，获得对数据库的连接。

```java
// java.sql.Connection 提供了以下控制事务的方法：

public void setAutoCommit(boolean)
public boolean getAutoCommit()
public void commit()
public void rollback()
```

使用 JDBC 事务界定时，您可以将多个 SQL 语句结合到一个事务中。
JDBC 事务的一个**缺点是事务的范围局限于一个数据库连接**。一个 JDBC 事务不能跨越多个数据库。

```java
private Connection conn = null;  

private PreparedStatement ps = null;  

try {  
    conn.setAutoCommit(false);  //将自动提交设置为false  

    ps.executeUpdate("修改SQL"); //执行修改操作  

    ps.executeQuery("查询SQL");  //执行查询操作                 

    conn.commit();      //当两个操作成功后手动提交  

} catch (Exception e) {  

    conn.rollback();    //一旦其中一个操作出错都将回滚，使两个操作都不成功  

    e.printStackTrace();  

} 
```

#### *.1、**自动提交模式(Auto-commit mode)**

Connection提供了一个auto-commit的属性来指定事务何时结束。

- **当auto-commit为true时（默认）**，当每个独立SQL操作的执行完毕，事务立即自动提交，也就是说每个SQL操作都是一个事务。

  ```
  一个独立SQL操作什么时候算执行完毕。
  
  1.JDBC规范是这样规定的：对数据操作语言(DML，如insert,update,delete)和数据定义语言(如create,drop)，语句一执行完就视为执行完毕。
  2.对select语句，当与它关联的ResultSet对象关闭时，视为执行完毕。
  3.对存储过程或其他返回多个结果的语句，当与它关联的所有ResultSet对象全部关闭，所有update count(update,delete等语句操作影响的行数)和output parameter(存储过程的输出参数)都已经获取之后，视为执行完毕。
  ```

- **当auto-commit为false时**，每个事务都**必须显示调用commit方法**进行提交，**或者显示调用rollback方法**进行回滚。

#### *.2、**事务隔离级别(Transaction Isolation Levels)**

JDBC提供了5种不同的事务隔离级别，在Connection中进行了定义。
JDBC定义了五种事务隔离级别：

```
TRANSACTION_NONE JDBC驱动不支持事务
TRANSACTION_READ_UNCOMMITTED 允许脏读、不可重复读和幻读。
TRANSACTION_READ_COMMITTED 禁止脏读，但允许不可重复读和幻读。
TRANSACTION_REPEATABLE_READ 禁止脏读和不可重复读，单运行幻读。
TRANSACTION_SERIALIZABLE 禁止脏读、不可重复读和幻读。
```

#### *.3、**保存点(SavePoint)**

JDBC定义了SavePoint接口，提供在一个更细粒度的事务控制机制。**当设置了一个保存点后，可以rollback到该保存点处的状态，而不是rollback整个事务。**

**Connection接口的setSavepoint和releaseSavepoint方法可以设置和释放保存点。**

### b、**JTA（Java Transaction API）事务**

JTA是一种高层的，**与实现无关的，与协议无关的API**，应用程序和应用服务器可以使用JTA来访问事务。

JTA允许应用程序执行**分布式事务处理**——**在两个或多个网络计算机资源上访问并且更新数据，这些数据可以分布在多个数据库上**。JDBC驱动程序的JTA支持极大地增强了数据访问能力。

### c、**容器事务**

容器事务主要是J2EE应用服务器提供的，容器事务大多是基于JTA完成，这是一个基于JNDI的，相当复杂的API实现。

## 3.3、三种Java事务差异?

**1、JDBC事务控制的局限性在一个数据库连接内，但是其使用简单。**
**2、JTA事务的功能强大，事务可以跨越多个数据库或多个DAO，使用也比较复杂。**
**3、容器事务，主要指的是J2EE应用服务器提供的事务管理，局限于EJB应用使用。**

# 四、数据库索引

## 4.1、作用

之所以要建立索引，其实就是为了构建一种**数据结构**，可以在上面应用一种高效的查询算法，最终提高数据的查询速度。

**索引的目的在于提高查询效率**，索引就像是书的目录，是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。 

**索引的原理在于使用空间换时间**，索引会将建立的索引KEY存储在N叉树（BTree）。

## 4.2、索引的优缺点

- **优点：**

① 建立索引的列可以保证行的唯一性，生成唯一的rowId

② 建立索引可以有**效缩短数据的检索时间**

③ 建立索引可以**加快表与表之间的连接**

④ 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序



- **缺点：**

① 创建索引和维护索引需要**时间成本**，这个成本随着数据量的增加而加大

② 创建索引和维护索引需要**空间成本**，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）

③ 会**降低表的增删改的效率**，因为每次增删改索引需要进行动态维护，导致时间变长

> 数据库的增、删、改操作，会触发索引的维护

## 4.3、什么情况下需要建立索引

-  数据量大的，**经常进行查询操作**的表要建立索引。
-  用于**排序的字段可以添加索引**，用于**分组的字段应当视情况**看是否需要添加索引。
-  表与表连接用于多表联合查询的约束条件的字段应当建立索引。

## 4.4、索引的种类

- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一（可以有null）
- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：对文本的内容进行分词，进行搜索

## 4.5、建立索引常用的原则，注意事项

1. **主键、外键要建索引**

2. 经常出现在where,on,group by,order by 中出现的列使用索引

3. 选择区分度高的列作为索引，也就是尽量不重复的

4. 对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键

5. **索引列不能参与计算**

6. 较长的字符串使用**前缀索引**

7. 不要过多创建索引

8. 对于like查询，”%”不要放在前面。 

   > ```
   > SELECT * FROM houdunwang WHERE uname LIKE '后盾%' -- 走索引` 
   > `SELECT * FROM`houdunwang`WHERE`uname`LIKE "%后盾%" -- 不走索引
   > ```

9. 查询where条件数据类型不匹配也无法使用索引 

10. 字符串与数字比较不使用索引; 

11. 索引字段建议建立NOT NULL约束 

## 4.6、什么情况下设置了索引但无法使用 

- 以“%”开头的LIKE语句，模糊匹配
- OR语句前后没有同时使用索引
- 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）

## 4.7、多加索引一定很好吗？

索引主要用于加速查询速度，但并发越多越好，因为索引需要占用物理空间的，且索引的维护需要时间的，所以**如果建索引，一般来说，应该查询的次数大于插入的次数，同时我们一般只对例如where或者having子句中涉及的字段进行设置索引**，因为其它的地方就算建立了索引，一般也用不到，只是浪费。

## 4.8、mysql给离散度低的字段建索引，导致问题

> 重复性较强的字段，不适合添加索引

MySQL给离散度低的字段添加索引，如性别设置索引，再以性别作为条件进行查询反而会更慢！



- 为什么性别不适合建索引呢？

访问索引需要付出额外的IO开销，从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO。

假如要从表的100万行数据中取几个数据，那么索引是非常高效的。

但是从100万行数据中取50万数据，比如性别字段，就需要访问50万次索引，再访问50万次表，加起来的开销并不会比直接全表扫描效率好。

- 解决方法，可考虑将性别字段设为表的聚集索引（一张表中只能有一个，一般是主键）、联合索引（性别字段要放在后面）

# 五、主键、外键、超键、候选键

- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
- 候选键：是最小超键，即没有冗余元素的超键。
- 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
- 外键：在一个表中存在的另一个表的主键称此表的外键。

# 六、左连接、右连接和内连接

- **左连接：左边有的，右边没有的为null**
- **右连接：左边没有的，右边有的为null**
- **内连接：显示左边右边共有的**（自动忽略两个表中对应不起来的数据）

# 七、插入一条数据，不知道数据库是否拥有，判断，有则不插入，无则插入

## `on duplicate key update`作用

语法：

对于某表，主键为id，当执行插入操作时

```sql
-- 执行
INSERT INTO user_admin_t (id,password) 
VALUES ('1','第一次插入的密码') 
```

若原表中没有`id = 1`的数据，是可以正常插入的。但是若已存在，则数据库会报错

```sql
[SQL]INSERT INTO user_admin_t (id,password) 
VALUES ('1','第一次插入的密码') 

[Err] 1062 - Duplicate entry '1' for key 'PRIMARY'
```

此时，对于已存在的数据，Mysql告诉我们，我们的主键冲突了，可以改变一下思路，当插入已存在主键的记录时，将插入操作变为修改：

```sql
-- 在原sql后面增加 ON DUPLICATE KEY UPDATE 
INSERT INTO user_admin_t (_id,password) 
VALUES ('1','第一次插入的密码') 
ON DUPLICATE KEY UPDATE 
id = 'UpId',
password = 'upPassword';
```

若存在重复的，增加语句ON DUPLICATE KEY UPDATE后，会将原记录（主键冲突）更新修改为`('UpId','upPassword') `

# 八、选择课程的平均成绩

- 需要用到group by 课程名，将课程名去重之后，对每一个课程的成绩进行avg()

# 九、MySQL数据库

## 9.1、存储引擎及其区别

### a、存储引擎简介

-  **MyISAM**管理非事务表。它提供高速存储和检索，以及全文搜索能力。

  > MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。
  >
  > 通过更改STORAGE_ENGINE配置变量，能够方便地更改MySQL服务器的默认存储引擎。

- **InnoDB**存储引擎提供事务安全表，具有众多特性，包括ACID事务支持。**(提供行级锁)**

### b、MyISAM和InnoDB区别

- **MyISAM不支持事务、也不支持外键**，但其访问（读）速度快，对事务完整性没有要求。 

- InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。**支持外键**

  >  但是比起MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

- **InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。**一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一； 

> InnoDB引擎是将索引和数据存储在同一文件下的，聚集索引的叶子节点存储的是行数据（必然有一个聚集索引，主键、非空唯一键、自动生成raw_id），而普通索引下的叶子节点存放数据是主键。
>
> 
>
> MyISAM是分开存储的（索引文件+数据文件），索引文件中B+树的叶子节点存放的是地址。

## 9.2、MySQL有哪些锁

**共享锁：**又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个
**排他锁：**又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.

## 9.3、为什么MySQL默认使用B+树，而不是AVL

### a、AVL在数据量大时，效率低下

- 当数据量太大时，AVL高度太高，导致进行查询时IO次数太多（与磁盘交互），效率低下
- 造成IO浪费。（磁盘以页作为基本单位进行交互，目标数据过少，即内存中只存储的是AVL的根节点，但是查询时，通过该根节点，去磁盘中查询）

### b、B树（多路搜索树，多叉AVL）

- 每个节点的关键字不止一个，1-> N
- 绝对平衡（AVL相对平衡）
- 节点都在同一水平线上

> AVL只能纵向发展，B树也可以横向发展

## 9.4、B树和B+树

- B树每个节点都存储数据，所有节点组成这棵树。B+树**只有叶子节点存储数据**（B+树中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，**所有的叶子结点使用链表相连，便于区间查找和遍历**，所有**非叶节点起到索引作用。**
- B树中叶节点包含的关键字和其他节点包含的关键字是不重复的
- B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。
- B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。
- B+树中所有的叶子结点使用链表相连，**便于区间查找和遍历**。B树则需要进行每一层的递归遍历。**相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。**

## 9.5、红黑树介绍

红黑树原理：

1. 每个节点都只能是红色或黑色的；
2. 根节点是黑色的；
3. 每个叶节点（空节点）是黑色的；
4. 如果一个节点是红色的，那么他的子节点都是黑色的；
5. 从任意一个节点到其每个子节点的路径都有相同数目的黑色节点；

## 9.6、如何定位慢查询（慢查询日志定位）

**MySQL 的慢查询日志记录的内容**是：在 MySQL 中响应时间超过参数 long_query_time（单位秒，默认值 10）设置的值并且扫描记录数不小于 min_examined_row_limit（默认值0）的语句。

### a、**慢查询日志使用步骤**

使用慢查询日志，一般分为四步：

- 开启慢查询日志（默认关闭）。 `set global slow_query_log = on;`

- 设置慢查询阀值（默认10s）。`set global long_query_time = 1;`

  > **查询时间只要大于这个值都将记录到慢查询日志中**

- 确定慢查询日志路径。` show global variables like "datadir";`

- 确定慢查询日志的文件名。`show global variables like "slow_query_log_file";`

## 9.7、**EXLPAIN分析慢查询**

Explain 可以获取 MySQL 中 SQL 语句的执行计划，比如语句是否使用了关联查询、是否使用了索引、扫描行数等。可以帮我们选择更好地索引和写出更优的 SQL 。

使用方法：在查询语句前面加上 explain 运行就可以了。

**Explain字段详解（重点关注加粗项）：**

| 列名            | 描述                                                   |
| --------------- | ------------------------------------------------------ |
| id              | 在一个大的查询语句中每个select关键字都对应一个唯一的id |
| **select_type** | select关键字对应的那个查询的类型                       |
| table           | 表名                                                   |
| partitions      | 匹配的分区信息                                         |
| **type**        | 针对单表的访问方法                                     |
| possible_keys   | 可能用到的索引                                         |
| **key**         | 实际上使用的索引                                       |
| key_len         | 实际使用的索引长度                                     |
| **rows**        | 预估的需要读取记录条数                                 |

## 9.8、回表与索引覆盖

对于以下两条查询语句：

```sql
select id from table where name='zhang'

select * from table where name='zhang'
```

> 每个索引对应一个B+树，都是存储在磁盘中的（IO操作）

对于第一条语句，可以直接在name对应的索引树中直接查找到id，不需要再进行其他查找

对于第二条语句，先在name对应的索引树中，查找到对应的主键id，然后会根据id，再查找一次主键索引，最终返回结果

> 所以不建议使用select * 进行查询

- 第一条语句中，存在**索引覆盖**
- 第二条语句中，**再次查找主键索引的过程，即为回表**



# 十、数据库优化

- 服务器硬件（机械硬盘 / 固态硬盘）
- MySQL服务器优化（linux环境比windows更稳定）
- SQL本身优化
- 反范式设计优化
- 索引优化

## 10.1、SQL语句优化

- 查询优化时，避免全表扫描。考虑在where及 order by涉及的列上建立索引

- 避免在where上对字段使用 `!=` 或 `<>`（不等于）、`or`、`like '%...'`操作。

- 避免在where子句中对字段进行 `null`值判断

  - 如

    ```sql
    select id from t
    where num is null
    ```

    可以在num上设置默认值0，从而确保num列没有null值，然后进行如下查询

    ```sql
    select id from t
    where num = 0
    ```

    

  > 以上（会导致引擎放弃使用索引，而进行全局扫描）

- `in`与`not in`慎用，（对于连续值，尽量使用`between`）

  - 如

    ```sql
    select id from t
    where num between 1 and 3
    ```

- 在where中避免使用表达式 、函数操作

- 关联子查询（join）会比子查询效率高

## 10.2、反范式优化

### a、三大范式

减少冗余，对新增、删除、修改是友好的

但是对查询不友好

- 一范式

  ```
  不满足一范式： 其中name-age字段不属于单一属性
  
  ----------------
  id   name-age  
  ----------------
  1     张三-23
  
  满足一范式：
  -------------------
  id   name     age  
  -------------------
  1     张三     23
  ```

  - 数据库表中的所有字段都只具有单一属性
  - 单一属性的列是由基本数据类型构成
  - 设计出来的都是简单的二维表

- 二范式

  - 要求表中只有一个主键，（不存在非主键列只对部分主键的依赖关系）

- 三范式

  - 每一个非主属性，既不部分依赖也不传递依赖于主键。（在第二范式的基础上消除了非主键对主键的传递依赖）

### b、反范式优化设计

> 范式约束的目的在于减少冗余，对增、删、改友好，但是对查询不友好
>
> 因为在查询时，需要对多个表进行查询

- 为了性能和读取效率，考虑适当对数据库设计范式的要求违反
- 允许存在**少量冗余**，即空间换时间

## 10.3、索引优化

- 范围条件放最后
- 最佳左前缀匹配原则
- 字符类型加引号

### a、最左匹配原则怎么理解？

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

**例如：**如果建立(a,b)顺序的索引，查询b = 2 是匹配不到(a,b)索引的；但是如果查询条件是a = 1 and b = 2或者a=1就可以。

再比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。

> 最左匹配原则都是针对联合索引

