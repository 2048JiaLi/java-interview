

# 一、数据库连接池

## 1.1、数据库连接池介绍

**数据库连接是一种关键的有限的昂贵的资源**。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。

**数据库连接池负责分配、管理和释放数据库连接**，它允许应用程序重复使用一个现有的数据库连接，而再不是重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。能明显提高对数据库操作的性能。

## 1.2、JDBC连接数据库步骤

- **一般来说，Java应用程序访问数据库的过程是**：

  ①装载数据库驱动程序；

  ②通过jdbc建立数据库连接；

  ③访问数据库，执行sql语句；

  ④断开数据库连接。

  

- **底层实现可以说成是队列**，比如可以用一个list实现一个简单的连接池

```java
public class MyDataSource implements DataSource {
//链表 --- 实现栈结构
privateLinkedList<Connection> dataSources = new LinkedList<Connection>();

//初始化连接数量
publicMyDataSource() {
  //一次性创建10个连接
  for(int i = 0; i < 10; i++) {
     try {
        //1、装载sqlserver驱动对象
        DriverManager.registerDriver(new SQLServerDriver());
        //2、通过JDBC建立数据库连接
        Connection con =DriverManager.getConnection(
         "jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer", "sa", "123");
        //3、将连接加入连接池中
        dataSources.add(con);
     } catch (Exception e) {
        e.printStackTrace();
     }
  }
}

@Override
publicConnection getConnection() throws SQLException {
  //取出连接池中一个连接
  finalConnection conn = dataSources.removeFirst(); // 删除第一个连接返回
  returnconn;
}

//将连接放回连接池
publicvoid releaseConnection(Connection conn) {
  dataSources.add(conn);
}
}
```

# 二、事务

## 2.1、什么是事务

**数据库事务**通常**指对数据库进行读或写的一个操作序列**。

- 它的存在包含有以下两个目的：
  - 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
  - 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

**系统中的事务**: 处理一系列业务处理的执行逻辑单元,该单元里的一系列类操作**要不全部成功要不全部失败。**

## 2.2、为什么使用事务

可以保证数据的一致性和完整性(避免异常和错误等导致的数据信息异常) 

## 2.3、事务的基本要素（ACID)

### a、原子性（Atomicity )

**事务的原子性是指事务必须是一个原子的操作序列单元。**

事务中包含的各项操作在一次执行过程中，**只允许出现以下两种状态之一**。
•全部成功执行。
•全部不执行。
任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只打所有的操作全部成功，整个事务才算是成功完成。

### b、一致性（Consistency )

**事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。**

### c、隔离性（Isolation) 

**隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰**。

**比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。**



在**标准SQL规范中，定义了 4个事务隔离级别**，不同的隔离级别对事务的处理不同， 如**未授权读取、授权读取、可重复读取和串行化**

- ①未授权读取
  未授权读取也被称为读未提交（Read Uncommitted),该隔离级别允许脏读取，其隔离级別最低。换句话说，如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有进行事务提交，而与此同时，允许另一个事务也能够访问该数据。举个例子来说，事务A和事务B同时进行，事务A在整个执行阶段，会将某数据项的值从1开始，做一系列加法操作（比如说加1操作）直到变成10之后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2、2变成3等），而对这一系列的中间值的读取就是未授权读取。

- ②授权读取
  授权读取也被称为读已提交（Read Committed),它和未授权读取非常相近，唯一的区别就是授权读取只允许获取已经被提交的数据。同样以上面的例子来说，事务 A和事务同时进行，事务A进行与上述同样的操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。

另外，如果说有一个事务C,和事务A进行非常类似的操作，只是事务C是将数据项从10加到 20,此时事务B也同样可以读取到20,即授权读取允许不可重复读取。

- ③可重复读取
  可重复读取（Repeatable Read),简单地说，就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的。因此该事务级別禁止了不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到 1，但是在下一次事务操作中，即使事务 B (注意，事务名字虽然相同，但是指的是另一次事务操作）采用同样的查询方式，就吋能会读取到10或20。

- ④串行化

串行化（ Serializable)是最严格的事务隔离级別。它要求所有事务都被串行执行，即事务只能一个接一个地进行处理，不能并发执行。

### d、持久性（Durability)

事务的**持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的**。

## 2.4、事务的并发问题

### a、脏读

脏读：A，B两事务，A事务会读取到B事务未提交的数据，然后B因为某些原因回滚数据，所以**A就读取了B没有提交的数据**，也称脏数据。

### b、不可重复读

不可重复读：在A事务中**对同一数据两次查询不一致**，可能原因是在A事务提交之前B事务对该数据进行了操作

### c、幻读

#### *.1、什么是幻读

在一次事务里面，多次查询之后，查询的结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做 `幻行`

#### *.2、为什么要解决幻读

在高并发数据库系统中，需要保证事务与事务之间的隔离性，还有事务本身的一致性。

#### *.3、如何解决幻读

- 多版本并发控制（MVCC）（快照读/一致性读）

  多数数据库都实现了多版本并发控制，并且都是**靠保存数据快照来实现的**。

  以 `InnoDB` 为例，每一行中都冗余了两个字断。一个是行的创建版本，一个是行的删除（过期）版本。

  具体的版本号（trx_id）存在 `information_schema.INNODB_TRX` 表中。

  版本号（trx_id）随着每次事务的开启自增。

  **事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。**

  普通的 select 就是快照读。

```
select * from T where number = 1;
```

  原理：**将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。**

- next-key 锁 （当前读）

next-key 锁包含两部分：记录锁（行锁）、间隙锁

**记录锁是加在索引上的锁，间隙锁是加在索引之间的。**（思考：如果列上没有索引会发生什么？）

```sql
select * from T where number = 1 for update;
select * from T where number = 1 lock in share mode;
insert into T values (...)
update T set number=''
delete from T where ...
```

原理：**将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。**

## 2.5、MySQL事务隔离级别

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

## 2.6、**三范式**

> 第一范式: 每个列都不可以再拆分.
>
> 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分.
>
> 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.

# 三、Java事务

实际上，一个Java应用系统，如果要操作数据库，则通过JDBC来实现的。增加、修改、删除都是通过相应方法间接来实现的，事务的控制也相应转移到Java程序代码中。因此，数据库操作的事务习惯上就称为Java事务。

## 3.1、为什么需要Java事务?

事务是为解决数据安全操作提出的，事务控制实际上就是控制数据的安全访问。

```
一个简单例子：比如银行转帐业务，账户A要将自己账户上的1000元转到B账 户下面，A账户余额首先要减去1000元，然后B账户要增加1000元。假如在中间网络出现了问题，A账户减去1000元已经结束，B因为网络中断而操作 失败，那么整个业务失败，必须做出控制，要求A账户转帐业务撤销。这才能保证业务的正确性，完成这个操作就需要事务，将A账户资金减少和B账户资金增加方 到一个事务里面，要么全部执行成功，要么操作全部撤销，这样就保持了数据的安全性。
```

## 3.2、Java事务的类型

Java事务的类型有三种：**JDBC事务、JTA（Java Transaction API）事务、容器事务。**

### a、**JDBC事务**

JDBC 事务是用 Connection 对象控制的。JDBC Connection 接口（ java.sql.Connection ）提供了两种事务模式：自动提交和手工提交。

> 在连接数据库时，会通过Connection 对象，获得对数据库的连接。

```java
// java.sql.Connection 提供了以下控制事务的方法：

public void setAutoCommit(boolean)
public boolean getAutoCommit()
public void commit()
public void rollback()
```

使用 JDBC 事务界定时，您可以将多个 SQL 语句结合到一个事务中。
JDBC 事务的一个**缺点是事务的范围局限于一个数据库连接**。一个 JDBC 事务不能跨越多个数据库。

```java
private Connection conn = null;  

private PreparedStatement ps = null;  

try {  
    conn.setAutoCommit(false);  //将自动提交设置为false  

    ps.executeUpdate("修改SQL"); //执行修改操作  

    ps.executeQuery("查询SQL");  //执行查询操作                 

    conn.commit();      //当两个操作成功后手动提交  

} catch (Exception e) {  

    conn.rollback();    //一旦其中一个操作出错都将回滚，使两个操作都不成功  

    e.printStackTrace();  

} 
```

#### *.1、**自动提交模式(Auto-commit mode)**

Connection提供了一个auto-commit的属性来指定事务何时结束。

- **当auto-commit为true时（默认）**，当每个独立SQL操作的执行完毕，事务立即自动提交，也就是说每个SQL操作都是一个事务。

  ```
  一个独立SQL操作什么时候算执行完毕。
  
  1.JDBC规范是这样规定的：对数据操作语言(DML，如insert,update,delete)和数据定义语言(如create,drop)，语句一执行完就视为执行完毕。
  2.对select语句，当与它关联的ResultSet对象关闭时，视为执行完毕。
  3.对存储过程或其他返回多个结果的语句，当与它关联的所有ResultSet对象全部关闭，所有update count(update,delete等语句操作影响的行数)和output parameter(存储过程的输出参数)都已经获取之后，视为执行完毕。
  ```

- **当auto-commit为false时**，每个事务都**必须显示调用commit方法**进行提交，**或者显示调用rollback方法**进行回滚。

#### *.2、**事务隔离级别(Transaction Isolation Levels)**

JDBC提供了5种不同的事务隔离级别，在Connection中进行了定义。
JDBC定义了五种事务隔离级别：

```
TRANSACTION_NONE JDBC驱动不支持事务
TRANSACTION_READ_UNCOMMITTED 允许脏读、不可重复读和幻读。
TRANSACTION_READ_COMMITTED 禁止脏读，但允许不可重复读和幻读。
TRANSACTION_REPEATABLE_READ 禁止脏读和不可重复读，单运行幻读。
TRANSACTION_SERIALIZABLE 禁止脏读、不可重复读和幻读。
```

#### *.3、**保存点(SavePoint)**

JDBC定义了SavePoint接口，提供在一个更细粒度的事务控制机制。**当设置了一个保存点后，可以rollback到该保存点处的状态，而不是rollback整个事务。**

**Connection接口的setSavepoint和releaseSavepoint方法可以设置和释放保存点。**

### b、**JTA（Java Transaction API）事务**

JTA是一种高层的，**与实现无关的，与协议无关的API**，应用程序和应用服务器可以使用JTA来访问事务。

JTA允许应用程序执行**分布式事务处理**——**在两个或多个网络计算机资源上访问并且更新数据，这些数据可以分布在多个数据库上**。JDBC驱动程序的JTA支持极大地增强了数据访问能力。

### c、**容器事务**

容器事务主要是J2EE应用服务器提供的，容器事务大多是基于JTA完成，这是一个基于JNDI的，相当复杂的API实现。

## 3.3、三种Java事务差异?

**1、JDBC事务控制的局限性在一个数据库连接内，但是其使用简单。**
**2、JTA事务的功能强大，事务可以跨越多个数据库或多个DAO，使用也比较复杂。**
**3、容器事务，主要指的是J2EE应用服务器提供的事务管理，局限于EJB应用使用。**

# 四、数据库索引

## 4.1、作用

之所以要建立索引，其实就是为了构建一种**数据结构**，可以在上面应用一种高效的查询算法，最终提高数据的查询速度。

**索引的目的在于提高查询效率**，索引就像是书的目录，是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。 

**索引的原理在于使用空间换时间**，索引会将建立的索引KEY存储在N叉树（BTree）。

## 4.2、索引的优缺点

- **优点：**

① 建立索引的列可以保证行的唯一性，生成唯一的rowId

② 建立索引可以有**效缩短数据的检索时间**

③ 建立索引可以**加快表与表之间的连接**

④ 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序



- **缺点：**

① 创建索引和维护索引需要**时间成本**，这个成本随着数据量的增加而加大

② 创建索引和维护索引需要**空间成本**，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）

③ 会**降低表的增删改的效率**，因为每次增删改索引需要进行动态维护，导致时间变长

> 数据库的增、删、改操作，会触发索引的维护

## 4.3、什么情况下需要建立索引

-  数据量大的，**经常进行查询操作**的表要建立索引。
-  用于**排序的字段可以添加索引**，用于**分组的字段应当视情况**看是否需要添加索引。
-  表与表连接用于多表联合查询的约束条件的字段应当建立索引。

## 4.4、索引的种类

- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一（可以有null）
- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：对文本的内容进行分词，进行搜索

## 4.5、建立索引常用的原则，注意事项

1. **主键、外键要建索引**

2. 经常出现在where,on,group by,order by 中出现的列使用索引

3. 选择区分度高的列作为索引，也就是尽量不重复的

4. 对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键

5. **索引列不能参与计算**

6. 较长的字符串使用**前缀索引**

7. 不要过多创建索引

8. 对于like查询，”%”不要放在前面。 

   > ```
   > SELECT * FROM houdunwang WHERE uname LIKE '后盾%' -- 走索引` 
   > `SELECT * FROM`houdunwang`WHERE`uname`LIKE "%后盾%" -- 不走索引
   > ```

9. 查询where条件数据类型不匹配也无法使用索引 

10. 字符串与数字比较不使用索引; 

11. 索引字段建议建立NOT NULL约束 

## 4.6、什么情况下设置了索引但无法使用 

- 以“%”开头的LIKE语句，模糊匹配
- OR语句前后没有同时使用索引
- 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）

# 五、主键、外键、超键、候选键

- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
- 候选键：是最小超键，即没有冗余元素的超键。
- 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
- 外键：在一个表中存在的另一个表的主键称此表的外键。

# 六、



# 七、插入一条数据，不知道数据库是否拥有，判断，有则不插入，无则插入

## `on duplicate key update`作用

语法：

对于某表，主键为id，当执行插入操作时

```sql
-- 执行
INSERT INTO user_admin_t (id,password) 
VALUES ('1','第一次插入的密码') 
```

若原表中没有`id = 1`的数据，是可以正常插入的。但是若已存在，则数据库会报错

```sql
[SQL]INSERT INTO user_admin_t (id,password) 
VALUES ('1','第一次插入的密码') 

[Err] 1062 - Duplicate entry '1' for key 'PRIMARY'
```

此时，对于已存在的数据，Mysql告诉我们，我们的主键冲突了，可以改变一下思路，当插入已存在主键的记录时，将插入操作变为修改：

```sql
-- 在原sql后面增加 ON DUPLICATE KEY UPDATE 
INSERT INTO user_admin_t (_id,password) 
VALUES ('1','第一次插入的密码') 
ON DUPLICATE KEY UPDATE 
id = 'UpId',
password = 'upPassword';
```

若存在重复的，增加语句ON DUPLICATE KEY UPDATE后，会将原记录（主键冲突）更新修改为`('UpId','upPassword') `

# 八、选择课程的平均成绩

- 需要用到group by 课程名，将课程名去重之后，对每一个课程的成绩进行avg()

# 九、MySQL数据库

## 9.1、存储引擎及其区别

### a、存储引擎简介

-  **MyISAM**管理非事务表。它提供高速存储和检索，以及全文搜索能力。

  > MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。
  >
  > 通过更改STORAGE_ENGINE配置变量，能够方便地更改MySQL服务器的默认存储引擎。

- **InnoDB**存储引擎提供事务安全表，具有众多特性，包括ACID事务支持。**(提供行级锁)**

### b、MyISAM和InnoDB区别

- MyISAM不支持事务、也不支持外键，但其访问（读）速度快，对事务完整性没有要求。 
- InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是比起MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。 

## 9.2、MySQL有哪些锁

**共享锁：**又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个
**排他锁：**又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.

## 9.3、B树和B+树

- B树每个节点都存储数据，所有节点组成这棵树。B+树**只有叶子节点存储数据**（B+树中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，**所有的叶子结点使用链表相连，便于区间查找和遍历**，所有**非叶节点起到索引作用。**
- B树中叶节点包含的关键字和其他节点包含的关键字是不重复的
- B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。
- B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。
- B+树中所有的叶子结点使用链表相连，**便于区间查找和遍历**。B树则需要进行每一层的递归遍历。**相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。**

## 9.4、红黑树介绍

红黑树原理：

1. 每个节点都只能是红色或黑色的；
2. 根节点是黑色的；
3. 每个叶节点（空节点）是黑色的；
4. 如果一个节点是红色的，那么他的子节点都是黑色的；
5. 从任意一个节点到其每个子节点的路径都有相同数目的黑色节点；

