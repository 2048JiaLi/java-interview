## 一、什么是线程

线程是操作系统能够进⾏**运算调度的最小单位**，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程 进⾏运算提速。

>  ⽐如，如果⼀个线程完成⼀个任务要100毫秒，那么⽤⼗个线程完成该任务只需10毫秒

## 二、什么是线程安全/不安全？

### 2.1 线程安全

多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完成，其他线程才可以使用。不会出现数据不一致或者数据污染。

### 2.2 线程不安全

不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

**线程安全问题都是由全局变量及静态变量引起的。**若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

## 三、线程同步的几种方式

### 3.1 Synchronized关键字

- 修饰方法`public synchronized …`，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

  > 注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会**锁住整个类**

- 同步代码块`synchronized(对象){}`，通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

  > 1.当synchronized作用在方法上的时候，锁住的就是这个对象的实例 synchronized(this). 
  >
  > 2.当一个线程访问synchronized(this) 同步块时， 另一个线程仍然可以访问当前对象内的非synchroinzed(this)同步块代码
  >
  > 3.同步是一个耗性能的操作，因此我们尽量减少同步的内容，最好不要加载整个方法上

### 3.2 volatile关键字

volatile关键字为域变量的访问提供了一种免锁机制

只需在account前面加上volatile修饰，即可实现线程同步

```java
class Bank {
            //需要同步的变量加上volatile
            private volatile int account = 100;

            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized 
            public void save(int money) {
                account += money;
            }
        ｝
```

1. 多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。

2. volatile不能保证原子操作，因此**volatile不能代替synchronized**

3. 每次要线程要访问volatile修饰的变量时都是从内存中读取，而不是从缓存当中读取，因此每个线程访问到的变量值都是一样的。这样就保证了同步。

### 3.3 java.util.concurrent包

## 四、什么是自旋锁

当线程A想要获取一把自旋锁而该锁又被其它线程锁持有时，线程A会在一个循环中自旋以检测锁是不是已经可用了。 

自旋锁需要注意：

- 由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直自旋，造成很大资源浪费
- 持有自旋锁的线程在sleep之前应该释放自旋锁以便其他线程可以获得自旋锁

目前JVM实现自旋锁会消耗CPU，自旋锁比较适用于锁使用者保持锁时间比较短的情况，此时效率较高。

自旋锁是一种对多处理器相当有效的机制，而在单处理器非抢占式系统中基本没有作用。