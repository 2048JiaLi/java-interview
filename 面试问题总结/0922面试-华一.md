[TOC]

## 一、java八大基本数据类型，与其对应的引用类型的区别

Java 提供两种不同的类型：引用类型和基本类型（或内置类型）；
`int` 是java 的基本数据类型，`Integer` 是java 为`int` 提供的封装类。

Java 为每个原始类型提供了封装类：

- 原始类型: `boolean,char,byte,short,int,long,float,double`
- 封装类型：`Boolean，Character，Byte，Short，Integer，Long，Float，Double`

引用类型和原始类型的行为完全不同，并且它们具有不同的语义。**引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题**，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为null，而原始类型实例变量的缺省值与它们的类型有关。

## 二、java集合，list、set、map，set不允许重复，若出现重复，怎么处理

### 2.1、List

- 集合中的对象按照索引的顺序排序，可以有重复的对象。**底层以数组实现**。
- List以线型方式存储，默认按元素的添加顺序设置元素的索引。

List集合的主要实现类：

1. ArrayList：可以理解为长度可变的数组。可以对集合中的元素快速随机访问，但是做插入或删除操作时效率较低。
2. LinkedList：使用链表的数据接口。与ArrayList相反，插入或删除操作时速度快，但是随机访问速度慢。同时实现List接口和Deque接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素，也能将LinkedList当作双端队列使用，自然也可以被当作"栈来使用（可以实现“fifo先进先出，filo后入先出”）

### 2.2、Set集合

- Set集合中的对象无排列顺序，且没有重复的对象。

- 对Set集合中成员的访问和操作是通过对集合中对象的引用进行的，所以Set集合不能有重复对象（包括Set的实现类）。

- Set判断集合中两个对象相同不是使用"=="运算符，而是根据equals方法。

  >  **每次加入一个新对象时，如果这个新对象和当前Set中已有对象进行equals方法比较都返回false时，则允许添加对象，否则不允许。**
  >
  >  > 判断若hash值与equals比较都相同，则直接返回（即不做任何操作）
  >
  >  HashSet的实现方式是基于HashMap实现的，内部定义了一个`private transient HashMap<E,Object> map;`

Set集合的主要实现类：

1. HashSet：按照哈希算法来存储集合中的对象，速度较快。
2. LinkedHashSet：不仅实现了哈希算法，还实现了链表的数据结构，提供了插入和删除的功能。当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。
3. TreeSet：实现了SortedSet接口（此接口主要用于排序操作，即实现此接口的子类都属于排序的子类）。
4. EnumSet：专门为枚举类设计的**有序**集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。

### 2.3、Map 集合

- Map是一种把键对象(key)和值对象(value)进行映射的集合（k-v）。k相当于v的索引，v仍然可以是Map类型(k-v)。
- key和value都可以是任何引用类型的数据。
- Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。
- key集的存储形式和Set集合完全相同(即key不能重复)
- value集的存储形式和List非常类似(即value可以重复、根据索引来查找)

Map集合的主要实现类：

1. HashMap：按照哈希算法来存取key，有很好的存取性能，和HashSet一样，要求覆盖equals()方法和hasCode()方法，同时也不能保证集合中每个key-value对的顺序。
2. LinkedHashMap：使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致。
3. TreeMap：一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。实现了SortedMap接口，能对key进行排序。TreeMap可以保证所有的key-value对处于有序状态。同样，TreeMap也有两种排序方式（自然排序、定制排序）

## 三、创建多线程的方式有几种？分别是什么？线程死锁是如何产生的？如何防止线程死锁现象？

- 方式：
  - 继承`Thread`、实现 `Runnable` 接口

- 产生:
  - 一个资源每次只能被一个进程使用
  - 一个进程因请求发生阻塞时，依然对已获得的资源保持不放
  - 进程已经获得资源使用权，但是一直未使用
  - 同一个进程，频繁的获取资源的优先使用权，一直未释放

- 防止：
  - 加锁顺序（线程按照一定的顺序加锁）
  - 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
  - 死锁检测（一般是将所有的锁存放于`map`对象中，检测`map`中的锁）

### 3.1、产生死锁的四个必要条件

- 互斥条件：在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则**请求进程只能等待**。

- 不可剥夺：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是**主动释放**)。

- 请求和保持：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

  > 请求其他资源得不到满足时，并不会释放已有资源

- 循环等待：存在一种进程资源的循环等待链

**以上这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁**

## 四、String、StringBuffer、StringBuild区别

1. 运行速度快慢为：`StringBuilder > StringBuffer > String`
   - （`String`为字符串常量，而`StringBuilder`和`StringBuffer`均为字符串变量，即`String`对象一旦创建之后该对象是**不可更改**的）
2. `StringBuilder`是线程不安全的，而`String`、`StringBuffer`是线程安全的

## 五、String创建的对象为什么不能修改

> https://www.cnblogs.com/leskang/p/6110631.html

JDK1.8，String源码

- 变量

```java
/** The value is used for character storage. */
private final char value[];

/** Cache the hash code for the string */
private int hash; // Default to 0
```

> String内部是字符数组的实现，且定义为`private final`。并没有提供额外的set方法来修改，所以String类的外部无法修改String。一旦初始化之后，就不能再修改。

虽然String类中提供的一些方法替换某些值，如replace， replaceAll， toLowerCase等。但是，在调用这些方法时，内部new了一个新的String对象（见源码）并返回。所以，这些方法并不是真的改变了原String的值。

## 六、拆箱与装箱及什么时候拆箱/装箱

> jdk5之后提供基本类型的自动装箱与拆箱

**装箱就是将基本数据类型转化为包装类型，那么拆箱就是将包装类型转化为基本数据类型**。

```java
public class TestBox {
    public static void main(String[] args) {
        //自动装箱，底层其实执行了Integer a=Integer.valueOf(1);
        Integer a = 1;
        //自动拆箱，底层其实执行了int b=a.intValue();
        int b = a;
    }
}
```

- Integer的`valueOf（int i）`方法可以将一个基本数据类型转化为对应的包装类型，即装箱方法。

- 而Integer的`intValue（）`方法则可以将一个包装类型转化为对应的基本数据类型，即拆箱方法。

### 6.1、装箱与自动装箱的区别

装箱：利用Integer的构造方法Integer（int value），即Integer c=new Integer(1);

自动装箱：或者叫隐式装箱，直接给Integer赋值，即Integer d=1,在编译的时候，会调用Integer.valueOf（）方法完成装箱。

相比而言，自动装箱可能比装箱具有更高的效率，体现在自动装箱的缓存上，下面从几道题目来讲自动装箱的缓存。

## 七、final关键字，放在变量、方法、类上产生什么效果

在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）

- 修饰类：当用final修饰一个类时，表明这个类不能被继承。

  > final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

- 修饰方法：该方法在子类中，不能被覆盖

  > 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。

  注：类的private方法会隐式地被指定为final方法。

- 修饰变量：对于一个final变量，如果是**基本数据类型**的变量，则其数值一旦在初始化之后便**不能更改**；如果是**引用类型**的变量，则在对其初始化之后便**不能再让其指向另一个对象**。

所见到的例子，是在单例模式中，可以将变量定义为final

## 八、数据库索引有什么作用，数据表创建索引选择哪些列作为索引

之所以要建立索引，其实就是为了构建一种数据结构，可以在上面应用一种高效的查询算法，最终提高数据的查询速度。

**索引的目的在于提高查询效率**，索引就像是书的目录，是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。 

**索引的原理在于使用空间换时间**，索引会将建立的索引KEY存储在N叉树（BTree）。

### 8.1、索引的优缺点

#### 优点：

① 建立索引的列可以保证行的唯一性，生成唯一的rowId

② 建立索引可以有**效缩短数据的检索时间**

③ 建立索引可以**加快表与表之间的连接**

④ 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序

#### 缺点：

① 创建索引和维护索引需要**时间成本**，这个成本随着数据量的增加而加大

② 创建索引和维护索引需要**空间成本**，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）

③ 会**降低表的增删改的效率**，因为每次增删改索引需要进行动态维护，导致时间变长

### 8.2、什么情况下需要建立索引

-  数据量大的，**经常进行查询操作**的表要建立索引。
-  用于**排序的字段可以添加索引**，用于**分组的字段应当视情况**看是否需要添加索引。
-  表与表连接用于多表联合查询的约束条件的字段应当建立索引。

### 8.3、数据库建立索引常用的原则

1、表的主键、外键必须有索引;

2、数据量超过300的表应该有索引;

3、查询时经常出现在Where子句中的字段，特别是大表的字段，应该建立索引;

4、索引应该建在选择性高的字段上;

5、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引;

6、频繁进行数据操作的表，不要建立太多的索引;

7、删除无用的索引，避免对执行计划造成负面影响;

## 九、事务的四个特性ACID

事务具有四个特征，分别足原子性（Atomicity )、一致性（Consistency )、隔离性（Isolation) 和持久性（Durability),简称为事务的ACID特性。

### 9.1、原子性（Atomicity )
事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，**只允许出现以下两种状态之一**。
•全部成功执行。
•全部不执行。
任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只打所有的操作全部成功，整个事务才算是成功完成。


### 9.2、一致性（Consistency )
事务的**一致性是指事务的执行不能破坏数据库数据的完整性和一致性**，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说，事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态，因此当数据库只包含成功事务提交 的结果时，就能说数据库处于一致性状态。而如果数据库系统在运行过程中发生故障， 有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。

### 9.3、隔离性（Isolation) 
事务的**隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰**。也就是说，不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的 各个事务之间不能互相干扰。



在**标准SQL规范中，定义了 4个事务隔离级别**，不同的隔离级别对事务的处理不同， 如未授权读取、授权读取、可重复读取和串行化

- ①未授权读取
  未授权读取也被称为读未提交（Read Uncommitted),该隔离级别允许脏读取，其隔离级別最低。换句话说，如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有进行事务提交，而与此同时，允许另一个事务也能够访问该数据。举个例子来说，事务A和事务B同时进行，事务A在整个执行阶段，会将某数据项的值从1开始，做一系列加法操作（比如说加1操作）直到变成10之后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2、2变成3等），而对这一系列的中间值的读取就是未授权读取。

- ②授权读取
  授权读取也被称为读已提交（Read Committed),它和未授权读取非常相近，唯一的区别就是授权读取只允许获取已经被提交的数据。同样以上面的例子来说，事务 A和事务同时进行，事务A进行与上述同样的操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。

另外，如果说有一个事务C,和事务A进行非常类似的操作，只是事务C是将数据项从10加到 20,此时事务B也同样可以读取到20,即授权读取允许不可重复读取。

- ③可重复读取
  可重复读取（Repeatable Read),简单地说，就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的。因此该事务级別禁止了不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到 1，但是在下一次事务操作中，即使事务 B (注意，事务名字虽然相同，但是指的是另一次事务操作）采用同样的查询方式，就吋能会读取到10或20。

- ④串行化

串行化（ Serializable)是最严格的事务隔离级別。它要求所有事务都被串行执行，即事务只能一个接一个地进行处理，不能并发执行。

### 9.4、持久性（Durability)
事务的**持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的**。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须被永久保存下来——即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。

## 十、new创建对象效率更高，为什么还要使用反射创建

### 10.1、什么是反射机制？

  在程序运行状态中，对于任意一个类或对象，都能够获取到这个类的所有属性和方法（包括私有属性和方法），这种动态获取信息以及动态调用对象方法的功能就称为反射机制。简单来讲，通过反射，类对我们是完全透明的，想要获取任何东西都可以。

### 10.2、反射的优点

1. 可以在程序**运行过程中，操作这些对象**；
2. 可以解耦，提高程序的可扩展性。

## spring的核心概念：IOC与AOP

## spring事务

## 个人职业规划

 