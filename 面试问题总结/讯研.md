## spring AOP

AOP（Aspect Orient Programming），即面向切面编程。是对OOP的一种补充。OOP将程序抽象成各个层次的对象，而AOP将程序抽象成各个切面。

传统OOP编程中，若存在重复代码，通常会将其抽象成一个方法，然后在需要的时候去调用该方法。而AOP要达到的效果是，保证开发者在不修改源码的前提下，去添加某种通用功能。

> python装饰器。
>
> 简单理解上，就是将源代码视为一个函数fun，在对其功能扩充时，python将函数fun以参数的方式传入到另一个函数fun2，在fun2中，只写对fun的功能扩充代码，并且是直接使用fun。

## mysql索引，及优点

## 如果插入一条数据，不知道数据库是否拥有，判断，有则不插入，无则插入

- `on duplicate key update`作用

语法：

对于某表，主键为id，当执行插入操作时

```sql
-- 执行
INSERT INTO user_admin_t (id,password) 
VALUES ('1','第一次插入的密码') 
```

若原表中没有`id = 1`的数据，是可以正常插入的。但是若已存在，则数据库会报错

```sql
[SQL]INSERT INTO user_admin_t (id,password) 
VALUES ('1','第一次插入的密码') 

[Err] 1062 - Duplicate entry '1' for key 'PRIMARY'
```

此时，对于已存在的数据，Mysql告诉我们，我们的主键冲突了，可以改变一下思路，当插入已存在主键的记录时，将插入操作变为修改：

```sql
-- 在原sql后面增加 ON DUPLICATE KEY UPDATE 
INSERT INTO user_admin_t (_id,password) 
VALUES ('1','第一次插入的密码') 
ON DUPLICATE KEY UPDATE 
id = 'UpId',
password = 'upPassword';
```

若存在重复的，增加语句ON DUPLICATE KEY UPDATE后，会将原记录（主键冲突）更新修改为`('UpId','upPassword') `

## 进程和线程的区别

- **根本区别**：进程是操作系统**资源分配**的基本单位，而线程是处理器**任务调度和执行**的基本单位

  > 每个进程都有自己独立的一块内存空间，一个进程可以有多个线程

- **资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

- **包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

- **内存分配**：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

- **影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

- **执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

## 进程之间的通信方式

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。

- 进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其它进程之间的互相通信来协调它们的行为。

IPC的方式通常有**管道（包括无名管道和命名管道）、消息队列、信号量、共享内存、Socket、信号 **。

### 进程通信的应用场景

- **数据传输**：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。
- **共享数据**：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。
- **通知事件**：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
- **资源共享**：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。
- **进程控制**：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

### 一、管道( pipe )：

管道包括三种:

- 普通管道PIPE： 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.
- 流管道s_pipe: 去除了第一种限制,为半双工，只能在父子或兄弟进程间使用，可以双向传输.
- 命名管道:name_pipe：去除了第二种限制,可以在许多并不相关的进程之间进行通讯.

### 二、信号量( semophore ) ：

- 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

### 三、消息队列( message queue ) ：

- 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

### 四、信号 ( sinal ) ：

- 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

### 五、共享内存( shared memory ) ：

- 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

### 六、套接字( socket ) ：

- 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。



## 给你一个项目，你想多线程还是多进程

- **什么情况下使用进程和线程：**

1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的
2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应
3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程
4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求
5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好

> 进程之间相互独立，安全性高，但是开销大
>
> 线程非常高效，但是一个线程死掉，就等于整个进程死掉

## 两个大小不匹配的表怎么连接

## OS调度算法

先来先服务

最短作业优先

最近最久未使用

高优先级

## linu查看进程占用内存

## linux常用命令

## http长连接和短链接

## http协议

## http三次握手和四次挥手

## https三次握手



## tcp三次握手为什么syn包

## jvm gc收集算法

## voliatile

## 可重入锁

## lock和synchronize的区别

| 类别     | synchronized                                                 | lock                                                         |
| :------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存在层次 | java的关键字，在jvm层面上                                    | 是一个类                                                     |
| 锁的释放 | 1、以获取锁的线程执行完同步代码，释放锁2、线程执行发生异常，jvm会让线程释放锁 | 在finally中必须释放锁，不然容易造成线程死锁                  |
| 锁的获取 | 假设A线程获得锁，B线程等待，如果A线程阻塞，B线程会一直等待   | 分情况而定，lock有多个锁获取的方法，可以尝试获得锁，线程可以不用功一直等待 |
| 锁状态   | 无法判断                                                     | 可以判断                                                     |
| 锁类型   | 可以重入，不可以中断，非公平                                 | 可重入 可以判断 可公平                                       |
| 性能     | 少量同步                                                     | 大量同步                                                     |

## sleep和wait

## concurrenthashmap

## hashmap底层实现原理

## 深拷贝和浅拷贝的区别

- 含义：假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。



深拷贝：除了对象本身被复制外，对象所包含的所有成员变量都会被复制，包括引用类型的成员对象



浅拷贝：只复制对象其中包含的值类型的成员变量，而引用类型的成员对象没有被复制

## 如何理解clone对象

### 1. 为什么需要clone

在实际编程过程中，我们常常要遇到这种情况：有一个对象 A，在某一时刻 A 中已经包含了一些有效值，此时可
能会需要一个和A完全相同新对象B，并且此后对B 任何改动都不会影响到A中的值，也就是说，**A与B是两个独立
的对象，但B的初始值是由A对象确定的**。在Java语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现clone（）方法是其中最简单，也是最高效的手段。 

### 2.  new 一个对象的过程和 clone 一个对象的过程区别 

- new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。
- clone在第一步是和new相似的，都是分配内存，调用clone方法时，分配的内存和原对象（即调用clone方法
  的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。 

> clone一般是返回一个浅拷贝的对象

## hashset去重原理

```
往Haset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，
    然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。
    
    情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。

    情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行 添加。
```

## hashcode

## stringbuilder和stringbuffer区别

## java常用jdk

## java集合

## LinkList底层

## Hashmap和hashtable区别

## hashmap底层原理

## 线程池

## 什么是死锁，线程几个状态，怎么接触死锁

## 多线程怎么实现

## 事务ACID

## 隔离级别

