## 一、说说什么是线程不安全

不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是**脏数据**。

> 数据库的脏读，是指，一个事务读取到了另一个事务未提交的数据。即事务A读取到了事务B准备提交的数据，但是事务B由于异常或其他原因，回滚数据，导致事务B的数据并没有提交成功。但是此时，事务A仍然读取到了该数据。

**举例说明**：假设售票系统有1000张票，A和B同时来买票，如果是线程不安全，那么可能售票系统可能出现1000-1去同时执行的情况，最终结果是A和B都买完后剩下999张票，而不是998张。

## 二、i++不是原子操作

`i++`做了三次指令操作，两次内存访问，第一次，从内存中读取i变量的值到CPU的寄存器，第二次在寄存器中的i自增1，第三次将寄存器中的值写入内存。

`i++`在作计算的时候要引入一个临时的变量，底层是这样实现的：

```java
tmp = i;
i = i+1;
i = tmp;
```

若换做是`j = i++;`则

```
tmp = i;
i = i++;
j = tmp;
```

## 三、JVM模型

- 程序计数器：当前线程所执行的字节码的行号指示器。
- 虚拟机栈：虚拟机栈描述的是 Java 方法执行的内存模型，栈帧结构，描述了局部变量表、操作数栈、动态链接、方法出口等信息。
- 堆：堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。
- 本地方法栈：线程开始调用本地方法时，会进入 个不再受 JVM 约束的世界。
- 方法区：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 四、HashMap线程不安全的表现

> new HashMap() 等价于 new HashMap（16,0.75）,即默认长度是16，扩容是原来的两倍。
>
> Hashtable默认是11

**扩容**就是在put加入元素的个数超过`initialCapacity * loadFactor`的时候就会将内部Entry数组大小扩大至原来的2倍。然后将数组**元素按照新的数组大小重新计算索引**，放在新的数组中，**同时修改每个节点的链表关系**（主要是next和节点在链表中的位置）。

HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会**触发扩容操作**，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，**在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环**，导致在get时会出现死循环，所以HashMap是线程不安全的。

## 五、HashMap的resize具体过程

HashMap通过resize()方法进行扩容为原来的两倍

首先计算并确定新容量的大小newCap，并且创建新表`Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];`

遍历将原来table中的数据放到扩容后的新表中来

如果是树结构（长度大于8），则将树上的节点放到新表

如果是链表，新元素的位置会根据旧元素位置+旧数组长度进行判定是否需要移动

```
如果（e.hash & oldCap） == 0则该节点在新表的下标位置与旧表一致
如果（e.hash & oldCap） == 1则该节点在新表的下标位置为 j+oldCap
```

- resize发生在table初始化或者table中的节点数超过阈值时
- 每次扩容会新建table，容量为原来的2倍
- 扩容时，会将原table的节点rehash到新table中，但节点在新旧table中的位置存在联系：要么下标相同，要么相差一个oldCap（旧table的大小）

## 六、索引的种类

- 普通索引：仅加速查询

- 唯一索引：加速查询 + 列值唯一（可以有null）

- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个

- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

- 全文索引：对文本的内容进行分词，进行搜索

> **使用索引的注意事项**
>
> 使用索引时，有以下一些技巧和注意事项：
>
> 1.索引不会包含有NULL值的列
>
> 2.使用短索引
>
> 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
>
> 3.索引列排序
>
> MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
>
> 4.like语句操作
>
> 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。
>
> 5.不要在列上进行运算
>
> 复制代码 代码如下:
> select * from users where YEAR(adddate)<2007;
>
> 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成:
>
> 复制代码 代码如下:
>
> select * from users where adddate<‘2007-01-01';
>
> 6.不使用NOT IN和<>操作8

## 七、http与https

HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

- HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全

- HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

### 7.1 主要区别

   1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

​    2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。

​    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

​    4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### 7.2  **客户端在使用HTTPS方式与Web服务器通信时的步骤**

​    （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL（Secure Socket Layer，安全套接字层）连接。

　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

　（3）客户端的浏览器与Web服务器开始**协商SSL/TLS连接的安全等级**，也就是信息加密的等级。

　（4）客户端的浏览器根据双方同意的安全等级，**建立会话密钥**，然后利用网站的公钥将会话密钥加密，并传送给网站。

　（5）Web服务器利用自己的私钥解密出会话密钥。

　（6）Web服务器利用会话密钥加密与客户端之间的通信。

### 7.3 HTTPS的缺点

- HTTPS协议多次握手，导致页面的加载时间延长近50%；
- HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；
- 申请SSL证书需要钱，功能越强大的证书费用越高。
- SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。

